R1: Was machst du fachlich im Job? Also bist du im Microservice-Development, Testing, oder DevOps oder?

I9: Ich habe vorher beim [Kollegen] mit im Team gearbeitet. Also war mit bei ihm im App-Server-Team, habe jetzt, seit diesem Jahr, bin ich in einem anderen Team. Unsere Aufgabe ist es unsere Software zukünftig auf Public-Cloud-Infrastruktur zu betreiben. Also sowas wie AWS oder GCP. Statt irgendwie eigenem Blech, was irgendwo in irgendeinem Rechenzentrum rumsteht und halt diese ganze Automatisierung, die halt nötig ist um diesen Betrieb zu gewährleisten. Wir wollen es halt mit Hilfe moderner Patterns so automatisiert und sich selbst heilend wie möglich betreiben. Das ist das Ziel meines Teams, beziehungsweise eigentlich meiner, sind noch ein paar andere Teams, die an dem selben Strang ziehen.

R1: Also DevOps dann praktisch sehr stark und Cloud?

I9: Genau. Also wir sind fast sogar so ein bisschen Ops-lastig, aber wir schreiben Code, also wir schreiben Code, der Betrieb macht, aber ich schreibe jetzt nicht wirklich, ich habe nicht, eigentlich nichts mit dem Shopsystem selbst zu tun. Ich schreibe keine Warenkorbkalkulation oder sowas. Sondern ich schreibe Code, der anderen Code betreibt.

R1: In welcher Domäne bist du? Backend—

I9: Ja. Ganz solide Backend.

R1: Welche Rolle in der Softwareentwicklung hast du? Also bist du Projektleiter, Scrum-Master oder Entwickler, oder?

I9: Entwickler.

R1: Welchen Anteil an deiner täglichen Arbeit hat denn Softwareentwicklung und Programmierung noch?

I9: Sehr hoch. Für mich. Also abgesehen von so den typischen Meetings, irgendwie jetzt Daily oder irgendwie Planungsmeetings oder sowas. Oder mal, keine Ahnung, mal ein All-Hands, wo irgendwie die Neuigkeiten werden. Ansonsten ist mein, der größte Teil meines Tages ist praktisch Arbeit an Tickets. Und die sind entwicklungslastig.

R1: Okay, wie viel Erfahrung hast du in der Softwareentwicklung? Wie viele Jahre?

I9: Fest eingestellt wurde ich, ich sage mal 2014 vielleicht, vielleicht ist es auch ein Jahr später oder. Ich weiß es nicht mehr ganz genau, aber ich sage einfach mal 5 Jahre.

R1: Wie lange hier schon in der Organisation?

I9: Hier in der Firma oder in meinem aktuellen Team?

R1: In der Firma.

I9: Seit drei Jahren.

R1: Und Team?

I9: Halbes Jahr.

R1: Mit welchen Frameworks und Tools arbeitest du denn für gewöhnlich?

I9: Wir haben im — wobei, ne, das stimmt gar nicht, wenn ich sage die meisten —, aber ich arbeite auf einem Mac. Die Kollegen haben noch Linux. Mein Haupttool ist wahrscheinlich die IDE, da nutzen wir IntelliJ. Oder ich benutze IntelliJ. Ansonsten relativ viel auch so auf der Konsole, wenn man irgendwie, manche Sachen mit Git machen wir auf der Konsole, oder wir — in meinem neuen Team arbeite ich jetzt relativ viel mit Kubernetes, da gibt es auch dieses kubectl-Commandlinetool, was so der zu Fuß weg ist, wo man mal so prototypen und ein bisschen rumspielen kann, bevor man es dann irgendwie in Code gießt. Also relativ viel Commandline, IntelliJ, Git, halt so die typischen, wie man als Entwickler irgendwie sein Zeugs versioniert und sowas. Wir haben einen Issuetracker. Unsere Firma hat sich entschieden einen eigenen Issuetracker zu bauen. Ich sage mal, da gibt es jetzt auch Luft nach oben.

R1: Frameworks? Habt ihr Spring Boot oder irgendwie sowas?

I9: Ich arbeite jetzt relativ viel mit Kubernetes und die Art und Weise wie man da programmiert, das nennt sich das Operator-Pattern und da schreibt man eine Art Microservice, die läuft auch selbst im Kubernetes und der stellt aber keine REST-API zur Verfügung, sondern der spricht mit der Kubernetes-API. Und der lauscht dann auf Events, der merkt dann zum Beispiel, keine Ahnung, irgendein Node ist abgekracht, okay da muss ich einen neuen hochfahren. Sowas, das ist die Art von Logik, die wir da bauen. Das lebt selbst im Kubernetes, wird irgendwie als Dockercontainer dahin deployt — also Docker machen wir auch — und der kanonische Weg, wie man die Operator schreibt, ist in Go. Wir schreiben Go und da gibt es dann so eine Library mit der man mit Kubernetes sprechen kann und genau. Das ist so unser täglich Brot.

R1: Dann steigen wir ein mit Konfiguration. Was verstehst du denn unter dem Begriff Konfiguration?

I9: Mir fällt es tatsächlich sehr schwer, weil es halt irgendwie sehr weitreichend ist. Es gibt halt verschiedene Arten von Konfiguration, verschiedene Level. Es gibt irgendwie so, keine Ahnung, wenn ich ein Stück schreibe, gibt es einmal so Sachen, die ich als Entwickler vielleicht einstellbar machen will. Da wo man vielleicht sowas, wie Features-Toggles, sowas will ich in der Lage sein einen Codepfad links und rechts zu schalten. Sodass ich irgendwie im Notfall die Handbremse ziehen kann oder bestimmte Sachen nur mal für einen Kunden mal freischalte. Das ist eine Art von Konfiguration. Dann natürlich so Umgebungskonfiguration. Sowas wie, wo liegt meine Datenbank, was sind die Credentials? Das sind vielleicht sogar zwei verschiedene Sachen, wenn du sagst das eine ist geheim und das andere ist nicht ganz so kritisch. Das gibt es. Was gibt es denn noch? Der Code selbst hat natürlich auch irgendwie eine Buildumgebung, die auch wieder Konfiguration hat, wo ich einstelle was habe ich für Dependencys, wo baue ich das Ding, dass es irgendeinen Jenkins hat. Der Jenkins braucht dann noch irgendwie Credentials um Artefakte irgendwo hochladen zu können. Aber das ist jetzt wahrscheinlich — na gut, aber irgendwann musst du anfangen und das muss auch irgendjemand mal gebaut haben. Ist jetzt nicht das, was du dann täglich hin- und hertoggelst, aber muss halt doch irgendwie da sein. Ich habe garantiert noch bei weitem nicht alles abgedeckt, aber —

R1: Habt ihr ja Kubernetes, oder, müsst ihr auch konfigurieren und, oder?

I9: Genau, Kubernetes selbst hat — also die Idee von Kubernetes ist, dass es eigentlich so eine zentrale Art Datenbank gibt, die den State des Clusters repräsentiert und das ist auch etwas, was wir — die Workloads, die wir dann tatsächlich ausführen, also das was der Code, den ich schreibe, dann tatsächlich bedient, der ist ja selbst auch wieder eine Art von Konfiguration. Dass man sagen kann ich will ein Shopsystem hochfahren und wem gehört denn der Shop, das Shopsystem und was ist das, wie groß soll das sein? So das ist auch eine Art von Konfiguration. Mein Code lauscht dann auf diese Konfiguration und stellt andere Konfiguration dann her und sagt dann dem Kubernetes leg mal einen Pod an und dann gibt es eine andere Stelle im Kubernetes, die dann sagt, okay dafür muss ich jetzt irgendwie her, keine Ahnung, mir ein Stück neues Blech von Google holen und darauf dann einen Dockercontainer starten oder sowas. Also das ist aus meiner Sicht als, wenn ich sage ich bin der Infrastruktur-Engineer, sind das eigentlich schon Nutzdaten. Ich weiß nicht, ob diese Unterscheidung sinnvoll ist, dass man sagt, Konfiguration ist so das, was quasi mein Laufzeitverhalten beeinflusst und Nutzdaten sind das, was mein Laufzeitverhalten, also was meine Logik dann massiert, das sind die Nutzdaten. Ich weiß nicht, ob ihr da einen Begriff habt, wie ihr das abgrenzt oder so. Also aus meiner Sicht ist das — also das kann ja durchaus sein, dass das, was für den einen Nutzdaten sind, ist für den nächsten die Konfiguration.

R1: Richtig. Ja, genau. Deswegen fragen wir auch jeden, was er darunter versteht. Wann konfiguriert ihr denn Software? Zur Laufzeit, zur Compilezeit?  

I9: Na, so ein bisschen hatte ich das ja schon angerissen, dass es ganz viele verschiedene Ebenen gibt. Der Klassiker ist in der Kubernetes-Welt eigentlich, dass man so eine Art Templatisierung hat, dass man für jedes Ding, was man in dieser Kubernetes-Welt instantiiert, sei es nun ein Pod in dem ein Container läuft oder sei das ein, keine Ahnung, ein Volume, was du dann irgendwo reinmountest oder irgendwas. Dass es da Templates gibt, in die man dann bestimmte Werte reinsetzen kann. Da kannst du dann sagen ich will jetzt ein Shopsystem hochfahren und das soll, keine Ahnung, diese Datenbank benutzen und diesen Username haben und der Rest ergibt sich dann mehr oder weniger von alleine. Das ist jetzt das eine, was mir spontan einfällt. Also was ich eben schon gesagt habe, zur Buildzeit gibt es dann andere Settings, die relevant sind. In gewisserweise betrifft es ja eigentlich jeden Cycle, also jeden Stage des Softwarelebenszyklus’. Von, ich setze mir überhaupt eine lokale Buildumgebung auf, bis ich mache irgendwie eine CI-Umgebung, ich mache vielleicht, ich lasse es mal lokal starten, ich habe vielleicht sogar für die IDE noch eine separate Konfiguration. Ich lasse es mal in einem Jenkins testweise irgendwo starten, bis hin zu, keine Ahnung, Preproduction, dann Productiondeployment, was dann, bis das Ding dann läuft, hat ja eigentlich jede Stufe ihre eigenen Anforderungen. Also für bestimmte Sachen, sowas wie, ich will etwas laufen lassen, da hat man wahrscheinlich die selben Settings, sowas wie wo liegt die Datenbank, ist _ein_ Setting, aber je nach Stage, hat es verschiedene Werte. Wohingegen sowas wie Compilezeit hat natürlich andere Settings, die man setzen muss, als für die Runtime-Settings.

R1: Wir unterteilen oft zwischen fachlicher und technischer Konfiguration. Fachlich ist da eher so vielleicht für den Kunden, deren ihre Features, technische ist dann CI/CD-Deployment und so weiter. In wie weit spielt denn diese fachliche und technische Konfiguration in deiner täglichen Arbeit eine Rolle? Und vielleicht auch das Verhältnis und so weiter. Bei dir ist natürlich schwierig. Wahrscheinlich ist deine fachliche auch gleichzeitig eine technische auf einer anderen Ebene.

I9: Also das, was wir haben, ist, es gibt eine Art abgespeckte API. Also es gibt eine separate REST-API, mit der man mit unserer Plattform reden kann und zum Beispiel sagen kann ich will jetzt mal eine neue Sandbox haben, das ist so ein kleines Shopsystem auf dem man als externer Entwickler lokal ein bisschen rumfummeln kann ohne jetzt irgendwie anderer Leute Zeug kaputt zu machen, kann man sagen ich will eine Sandbox haben. Dafür gibt es eine REST-API und in der REST-API ist die Gesamtmenge an _was brauche ich denn an, was muss ich wissen um tatsächlich irgendwie einen Dockercontainer hochzufahren_, ist da auf das eingedampft, was der Nutzer überhaupt kennen kann und wissen sollte. Also sowas wie, bestimmte Sachen hängen davon ab, wenn der Nutzer eingeloggt ist, hängen bestimmte Sachen, zum Beispiel zu welcher Organisation gehört der und wie funktioniert das Billing, wem muss ich was in Rechnung stellen, kommt einfach durch den Login des Nutzers. Andere Sachen kann der Nutzer auch selber einstellen. Das sind aber ganz wenige Sachen und das Gros an Konfiguration, sowas wie was ist der Hostname der Datenbank, das weiß der Nutzer natürlich nicht, soll er auch gar nicht wissen, das machen wir intern. Das ist eigentlich, vieles davon ist technisch und ich glaube der beste Weg um diese Trennung zu machen ist tatsächlich zwischen was ist direkt im Kubernetes drin, auf den Kubernetes-Cluster selbst oder auf die APIs davon hat der Kunde keinen Zugriff. Das machen wir intern. Da ist alles drin, fachlich wie technisch und wir entscheiden uns dann, was exposen wir nach außen mit einer separaten API.

R1: Und was — eine größere Rolle ist bei dir die technische in deiner Arbeit.

I9: Ja, würde ich so sagen.

R1: Gibt es denn Interaktionen zwischen fachlicher und technischer Konfiguration? Also bedingt das eine das andere vielleicht irgendwie?

I9: Weiß ich gerade nicht. Aktuell sind wir noch — also das, woran ich arbeite — relativ früh in der Phase. Relativ viele Sachen über die wir uns Gedanken machen sind eher so non-functional Requirements. Sowas wie Backup oder sowas, was jetzt nicht direkt was ist, was der Kunde einstellen oder machen wollen würde, aber in gewisserweise spielt natürlich was der Kunde will schon auch eine Rolle für uns, für keine Ahnung, es gibt halt Kunden, die einfach größere Shops haben, die müssen entsprechend vielleicht größere Instanzen von vorneherein provisioniert bekommen oder — Und das sind hauptsächlich Sachen, die bei uns, unsere Produktmanager diskutieren und treiben. Da bin ich als Entwickler relativ wenig involviert. Das macht entweder mein Manager oder mein, ich hab noch einen Tech-Lead bei mir im Team, der auch sehr involviert ist. Der hängt mit den Diskussionen mit Übersee et cetera immer mit in der Leitung und bereitet das für mich mundfertig vor.

R1: Hast du denn mit der Konfiguration von einem monolithischen System zu tun?

I9: In gewisserweise ja, weil das, was wir betreiben ist ja der Monolith plus noch ein bisschen drumherum, aber das, was wir im Endeffekt hochfahren wollen, ist das, was ich vorher in dem, in meinem vorherigen Team gebaut habe. Also da fällt halt diese ganze Menge Konfigurationsparameter, welche Datenbank ist jetzt noch so das erste Beispiel, was mir gerade einfällt, weil daran arbeite ich auch gerade, aber da gibt es, ich weiß gar nicht wie viele, also ich kann sie nicht alle aufzählen, aber es ist—

R1: Dutzende oder hunderte oder—?

I9: Hunderte? Naja. Aber dutzende trifft es, ja. Also keine Ahnung, ich würde mal sagen 50 plus minus irgendwie. Und das wird wahrscheinlich noch nicht mal reichen. Wahrscheinlich müssten es wahrscheinlich sogar noch mehr sein oder so, aber das ist das, was es so bisher gibt. Ist eine große Zahl.

R1: In wie weit müssen denn bei euch auch die Tools und die Frameworks, die ihr vielleicht benutzt oder die Infrastruktur konfiguriert werden?

I9: Ja.

R1: Natürlich jetzt vielleicht die Frage nicht zum Ops jetzt—

I9: Warte mal, ich tue mich gerade schwer mit der Frage.

R1: Die zielt zum Beispiel darauf, wenn man jetzt Microservices entwickelt, man nutzt da Spring Boot für ein Framework, dann muss man das Spring-Boot-Framework irgendwie konfigurieren und man muss vielleicht den Buildprozess konfigurieren. Den Gradle oder was weiß ich (I9: Genau), den Docker muss man irgendwie konfigurieren—

I9: Ich glaube Buildprozess konfigurieren ist ein durchgängiges Thema, was wahrscheinlich jeden Entwickler trifft. Also selbst wenn du, selbst die JavaScript-Leute bei uns, die jetzt keine kompilierte Sprache haben, selbst die haben einen Prozess, der irgendwie Sachen paketiert und in ein Repo hochlädt und Tests ausführt und — selbst die, wenn kein Compiler läuft, die müssen irgendwie ihr Code-Schaufeln müssen die irgendwie einrichten. Also das hat immer irgendeine Form von Konfiguration mit sich, ganz unabhängig davon, welcher Compiler oder überhaupt jetzt aufgerufen wird, aber so Buildautomatisierung hat eigentlich jeder. Also ich hoffe mal ganz stark, so die Zeiten in denen man irgendwie mit FTP-Servern irgendwie einzelne Files hin und her und dann auf den Productionserver irgendwie direkt oder so, das ist hoffentlich vorbei. Bei uns jedenfalls in der Firma ist das so. Darüber hinaus, es gibt tatsächlich relativ viel, was so drumherum gehört. Ich habe jetzt relativ viel von Kubernetes gesprochen. Das setzt voraus, dass es schon eine konfigurierte Kubernetesumgebung gibt. Bei Amazon und Google kann man sich sowas schon als managed Service kaufen. Das nimmt einem ein Gros der eigenen Administrationsarbeit ab, aber man muss das trotzdem irgendwie — man muss zum Beispiel sagen okay welche Version von Kubernetes haben wir, man muss sich überlegen wenn es Updates gibt, wann rolle ich die aus. Das hat halt doch einen gewissen Impact auf die Workloads und neben dem eigentlichen, diesem Mechanismus, der Clustersoftware managet und so reaktiv auf Events reagiert, gibt es natürlich noch andere Entscheidungen. Sowas wie, auf welchen Nodes läuft unser Workload tatsächlich. Also das Blech, was unten drunter ist, was von Kubernetes abstrahiert wird, das, an irgendeinem Punkt läuft es halt doch auf sowas, wie einer VM. Wie groß ist die? Wie viel RAM hat die? Da hängt dann natürlich auch Billing dran. Authentication ist ein großes Thema, es muss halt irgendwie Serviceaccounts geben, wir müssen irgendwie bestimmen, wer darf überhaupt mit diesem Cloudprovider reden. Also unsere Entwickler dürfen das vielleicht, aber wer darf was. Es darf nicht jeder alles. Ich hatte gerade noch irgendwas, jetzt habe ich es vergessen. Mist.

R1: Gibt es denn so Abhängigkeiten oder Interaktionen von Frameworks oder Tools, die ihr nutzt, zu vielleicht Infrastruktur. Also wenn ihr jetzt, weiß nicht, eure Cloud-Infrastruktur, ist die abhängig in der Konfiguration von dem, was ihr im Framework konfiguriert oder so? Oder anders herum?

I9: Ja, also sowas wie zum Beispiel, welche Kubernetes-Version benutzen wir, bestimmt natürlich in gewisser Weise auch welche APIs wir callen können oder bestimmte Sachen werden vielleicht auch — also einmal kommen neue Sachen dazu, andere Sachen werden deprecatet. Vielleicht kommt auch mal — eigentlich sollte es nicht sein —, aber vielleicht kommt auch mal irgendso ein Breaking Change rein, der eigentlich hätte stabil sein müssen. Also das muss schon irgendwie ein Match da sein. Achso, was ich noch sagen wollte: Für alles, was um Kubernetes drum herum geht, benutzen wir noch Terraform. Das ist so unser Mechanismus um quasi aus so einem nackigen Cloudaccount einen zu machen in den wir dann mit Kubernetes unsere Sachen deployen können. Dazu zählt sowas wie Nutzeraccounts anlegen. Auch so Storagesachen vorbereiten und auch in Richtung Continuous Delivery so die Brücke herzustellen zu den Tools, die dann einen Rollout von Software orchestrieren. Also Terraform gehört noch mit dazu. Das betrifft mich nicht persönlich, ich muss damit nicht arbeiten, ich kann davon ausgehen, dass das schon da ist, aber ein Schwesterteam von uns, die machen hauptsächlich sowas. Die machen quasi die Basis für uns und die legen so die, aus meiner Sicht, lowleveligeren Sachen bereit. Das ist einen Account gibt in den ich mich einfach einloggen kann und dann ist da im Prinzip alles schon da, dass ich anfangen kann gegen Kubernetes zu schießen.

R1: Wie würdest du denn eigentlich den Stellenwert oder die Wichtigkeit von Konfiguration in der Softwareentwicklung sehen?

I9: Tja, ohne läuft es halt nicht. Also das ist schon relativ klar, dass man das — ja, jede Software hat irgendeine Form von Abhängigkeit zu anderen Sachen oder zum Rest der Welt und das will man natürlich in den wenigsten Fällen irgendwie hardcoden, sondern meistens sagt man, keine Ahnung, wenn du ein Shopsystem hast, wir wollen wir mehr als einen Shop hosten können. Dann musst du einstellen können, okay, wem gehört der jetzt. Mit welcher Datenbank spricht, wie authentisiert man sich bei dem. Genau, also reicht dir das als _sehr hoch_?

R1: Ja klar. Gibt es denn Unterschiede in der Wichtigkeit in den verschiedenen Software-Lebensphasen? Also wenn man anfängt mit Requirements und so weiter.

I9: Ach, Requirements. Das ist natürlich ein guter Punkt, ja. Also das ist, das wäre natürlich äußerst wünschenswert, wenn man von vorneherein eine Idee hätte was denn so, also vielleicht einfach nur so als Blackboxbetrachtung. Was muss man einstellen, damit am Ende irgendein bestimmtes Ergebnis herauskommt. Also wenn man sich um so eine API Gedanken macht, dass man sagt, okay ich als Kunde will sagen können, ich bin der und der und ich brauche das und das, aber ich will nicht wissen müssen, was ist die URL von dem und dem. Also sich an der Stelle schon Gedanken zu machen, was ist required, was ist vielleicht sogar optional und was sollte vor dem Endkunden versteckt sein. Und in gewisserweise das gleiche auch für den quasi internen Stakeholder. Der muss unter Umständen die Sachen einstellen, die halt versteckt sind, aber auch für den stellt sich die Frage was sollte er wissen, was sollte er vielleicht von anderen abfragen oder sich irgendwo herholen, was davon ist optional, was lässt er weg, was ich vielleicht ein deprecatetes Feature, was man theoretisch einstellen kann, aber wir wollen es nie wieder aktivieren oder sowas. Genau, na das ist natürlich für — sehr nützlich, wenn man sich anhand dieser Schnittstellenbeschreibungen durch eine Story hangeln kann. Wenn man genau weiß, okay das muss irgendwie mal noch abhaken können und dann weiß man, okay der Weg, wenn ich das Setting habe und ich weiß wie es funktioniert, dann kann ich mir ein Bild draus machen, wie ich das umsetze, dass dieses Setting auch respektiert wird.

R1: Wurdest du denn während deines Studiums darauf vorbereitet auf Konfigurierbarkeit oder Konfiguration?

I9: Ich würde eigentlich generell nicht sagen, dass ich besonders gut auf Softwareentwicklung vorbereitet wurde. Also klar, man hat mal ein Programmierpraktikum gemacht und ich kann so Syntax und Semantik von Java, aber so wie tatsächliche Software aussieht über so ein Hello-World-Beispiel oder irgendwas, was man from Scratch angefangen und kann man da 3 + 5 eingeben und dann kommt da irgendwie — wir haben relativ viel so kleine Beispiele gemacht und wenig, ja, Szenarien gemacht in denen es sich auch tatsächlich mal gelohnt hätte über so Fragen wie Konfigurierbarkeit überhaupt nachzudenken. Wenn du nur Hello World schreibst, da kannst du irgendwie, dass du deinen Namen eintippen kannst und dann schreibt der _Hallo Olli_, sowas haben wir mal gemacht, aber das ist ja doch — also was du ansprichst denke ich ist doch eher ein Problem, wie man so sagt, Programming in the large. Wenn man wirklich größere Probleme hat und man muss Komplexität managen. Diese Domäne Komplexität zu managen, in die sind wir in meinem Studium nicht wirklich vorgedrungen. Beziehungsweise nur so mit abstrakt und ich mache irgendwie Klassendiagramm oder irgendwelchen anderen UML so Bla, aber so wirklich, dass ich sage ich habe eine Idee, wie man das tatsächlich dann macht oder so, kann ich nicht bestätigen. 28:10 Ist schade. Fände ich wichtig, aber —

R1: Genau, also meine Frage danach, sollte es im Studium unterrichtet werden? Also Konfigurierbarkeit oder Konfiguration?

I9: Ich glaube nicht, dass das etwas ist, was eine klassische Vorlesung ausfüllen würde. Das ist halt so gewisserweise ein klassischer crosscutting Concern. Es betrifft irgendwie alle, die irgendwas mit Software machen und entsprechend sollte das wahrscheinlich irgendwie eingebettet sein in _wir machen was mit Software_. Wie auch immer die Vorlesung dann heißt. Aber generell sich den, wie ich es gerade vorher schon angesprochen habe, sich dem Problem von Programming in the large zu stellen, auch sowas wie, dass man überhaupt über Buildautomatisierung nachdenkt, dass man über Continuous Integration nachdenkt. Das sind Sachen, die habe ich zufällig mitbekommen, weil ich ein Praktikum gemacht habe, ein freiwilliges, im Studium, aber die Uni hat mich das leider nicht gelehrt. Fände ich aber großartig.

R1: Gehen wir über zu wie arbeitet man so mit Konfiguration. Wie werden denn bei euch Konfigurationen verwaltet und dokumentiert?

I9: Ich beschränke mich mal noch mal auf Kubernetes. Das ist das, was jetzt so direkt meine Welt ist und mit der ich zu tun habe. Das Konzept in Kubernetes ist — wie schon gesagt, es so eine Art Datenbank und man kann eigene Customtypen anlegen und für die gibt es dann auch ein Schema und da kann man sagen ich habe ein Objekt, das heißt foo und das hat dann drei Felder, das eine heißt bar, ist ein String, das andere ist baz und ist ein Int oder sonstwas. Und dazu kann man auch direkt, also es gibt da ein Schema, das legt man auch mit dem Schema an und Kubernetes sagt nein, wenn das, was man versucht reinzustecken nicht dem Schema entspricht. So ein bisschen wie eine Datenbanktabelle quasi auch. Und das Schema aber selbst wieder auch ein Objekt, was in Kubernetes versioniert ist und dafür gibt es auch so Desciption Fields, wo man tatsächlich Freitext eingeben kann. Man kann auch gewisse Constraints eingeben, man kann sagen dieser String kann nur die folgenden drei Werte, grün, blau und weiß, enthalten oder sowas. Das ist hauptsächlich das, was wir machen. Ich habe festgestellt in meiner Erfahrung, es ist relativ schwierig Dokumentation nützlich zu halten, wenn sie nicht demselben Lebenszyklus wie die Software unterliegt. Also keine Ahnung, ich sage mal ein Markdown-File, was mit im Git-Repo liegt, mit anzupassen und dann in einem Pull-Request direkt zu sagen ich passe jetzt die Doku an und mache die Codeänderung dazu, das klappt vielleicht. Aber sowas, der klassische Weg ist irgendwie, Doku irgendwie gigantische Tabellen oder irgendwas in das Confluence zu werfen und da macht sich einer ein Mal viel Arbeit das anzulegen und der nächste ändert irgendwas am Code und weiß aber vielleicht aber gar nichts von dem Dokument und dann driftet das irgendwie auseinander und dann geht auch die Nützlichkeit der Dokumentation ganz schnell ganz weit runter wenn das dann irgendwie nicht mehr zutreffend ist, insofern… Also ich glaube das es sehr sinnvoll ist Sachen nah beieinander leben zu lassen, dass sie irgendwie einen Lebenszyklus teilen und dann ist es auch deutlich leichter zu sagen — man kann vielleicht sogar irgendwelche, keine Ahnung, Checks im CI einbauen, dass man sagt wir gehen durch unser Schema durch und jedes Field muss eine Description haben. So wenn man vergisst eine Description, dann sagt der Jenkins rot. Könnte man machen. Haben wir jetzt nicht konkret, aber das wären Sachen über die man nachdenken könnte, dass man die Dokumentation selbst als Teil des der Automatisierung unterliegenden Gesamtprozesses sieht.

R1: Ihr habt ja das wie gesagt mit dem Schema, hast du ja gesagt. Was ist denn der größte Vorteil von dieser Verwaltung? Also ich nehme mal an ihr habt ein Objekt ist dann eine Konfiguration bei euch dann, oder?

I9: Ein Objekt ist bei uns so ein Shop quasi. Und an dem stehen dann verschiedene Sachen dran. Ein Teil davon, wie gesagt, kommt vom Endnutzer quasi, ein Teil davon oder ein großer Teil — ne, beziehungsweise. Anders, dieses Objekt — Der Lebenszyklus funktioniert so: Wenn man ein Objekt anlegt ist das für Kubernetes die Aufforderung lege mir ein Shopsystem an. Und andere lauschen, ob ein Objekt angelegt wird und reagieren entsprechend. Das heißt dann zum Beispiel, die legen dann andere Objekte an, die dann die eigentlichen Kubernetes-Objekte sind, mit denen weiß dann Kubernetes was anzufangen. Da heißt es erstmal dann, fahr jetzt mal den Dockercontainer hoch und wenn es eine Produktionsinstanz ist, dann fährst du davon drei Stück hoch damit die redundant sind und irgendwie ein bisschen Lastverteilung machen können, wenn es eine Sandbox ist, dann nur einen. So dieses Container hochfahren das macht Kubernetes, aber dieses Mapping das macht unser Code und die Eingabedatenmenge für das Mapping ist — was es auslöst, diese Logik ist, dass so ein Objekt angelegt wird, so ein Shop-Objekt und dann fließen noch andere Sachen rein, sowas wie es gibt eine Konfiguration in der steht drin, es gibt eine Datenbank, die hat folgende Credentials und folgende URL. Sowas gibt es zum Beispiel und von diesen Objekte gibt es wieder mehrere und die haben Labels und man kann dann sagen ich suche ein Objekt oder ich suche Objekte mit dem Label Datenbank. Dann kommen da zum Beispiel drei Konfigurationen für eine Datenbank zurück und dann kann ich, wenn ich mir einen neuen Shop provisioniere, kann ich mir aussuchen, auf welche der drei Datenbanken gehe ich.

R1: Wo stehen diese Datenbank-Konfigurationen dann drin?

I9: Das ist auch wieder eine Art Map-Objekt im Kubernetes selbst. Es gibt da etwas, das heißt Config Map, das verhält sich wie eine Map<String, String> in Java.

R1: Also ist eine Konfiguration praktisch am Anfang wird die komponiert aus mehreren Konfigurationsteilen und das ist dann praktisch, eine Konfiguration ist dann wie ein Graph mit Unterkonfigurationen? Kann man das so dann verstehen? Also—  

I9: Naja, mir fällt es selbst ein bisschen schwer, die — es ist halt so ein Gesamtsystem in dem alles irgendwie immer so ein bisschen fließt. In sofern ist es schwierig da die Grenzen zu ziehen. Eine Datenbank-Konfiguration in dem Fall wäre ein für sich stehendes Objekt. Das ist wie eine Mappe, da steht drin Host ist foo und Adminusername ist bar und blablabla. Das ist eine Mappe und die bezeichnet eine Datenbank. Und diese Mappe hat noch ein Label dran, da steht dran _Datenbank_. Und die Logik, die ich vorhin beschrieben habe, die auf so ein Shopsystemobjekt lauscht, würde dann, wenn eins angelegt wird, schauen okay auf welche Datenbank lege ich diesen Shop und dafür dann nach diesem Laben queryien. Also das sind getrennte Objekte aber es gibt Logik, die die dann, oder sie fließen in der Logik zusammen und führen dann zu einem bestimmten Verhalten.

R1: Was ist denn der große Vorteil von dieser Verwaltung?

I9: Jetzt konkret für Kubernetes bezogen, oder? Wie generisch meinst du das?

R1: Ja, also was hat das für einen Vorteil, dass unsere Konfiguration so zu speichern, Kubernetes oder nicht vielleicht extern zu speichern in GitHub oder so.

I9: Kann man auch machen. Das coole an Kubernetes, es gibt halt diese generische API mit der man sprechen kann und alles unterliegt so einem automatischen Lebenszyklus-Management. Man kann halt watchen auf Sachen, man kann auf etwas lauschen und wird dann vom Framework gecallt. Quasi so ein Hollywood-Prinzip, so _Don’t call us, we call you_. Man wird gecallt, hier es ist etwas passiert und dann kann man seine Logik anwerfen und bestimmte Sachen machen. Und man kann auch relativ einfach sagen irgendwas hat nicht gestimmt, keine Ahnung, jemand hat ein Shopsystem angelegt, aber es sind keine Datenbanken konfiguriert, dann crashe ich, dann fliegt meine Logik weg und dann weiß Kubernetes das muss ich noch mal probieren. Und dann gibt es so eine Art exponential (?36:49)-Mechanismus, der callt das immer wieder und der crasht immer wieder, aber irgendwann hat es vielleicht jemand gesehen, hat eine Datenbank angelegt und dann läuft die Logik durch. Also das ist so eine Art selbstheilender Mechanismus, der einmal auf Umgebungseinflüsse lauscht und wenn er merkt irgendwas hat nicht funktioniert, dann so einen automatischen Retry hat, der — da muss man ein bisschen Hirnschmalz reinstecken, das klug zu durchdenken, aber wenn man es richtig macht, ist das selbstheilend. Das ist eigentlich ein ganz cooler Mechanismus. Und das betrifft halt einmal, wie du es vorhin gesagt, quasi fachliche Konfiguration, das wäre jetzt sowas das Shopsystemobjekt und auch technische Konfiguration, das wäre so die Datenbank konfigurieren wäre so ein ganz klassisches technisches Ding. Das wird nie ein Kunde zu sehen bekommen und das lebt aber halt, oder unterliegt in der Hinsicht denselben Mechnismen und den selben Vorzügen mit diesem ich kann es watchen und das heilt sich selbst und so weiter.

R1: Okay, was ist denn der größte Nachteil dieser Verwaltung?

I9: Es gibt keinen. (lacht)  

R1: Das hat bisher von keiner gesagt.

I9: Ich weiß nicht. Ich bin wie gesagt erst tatsächlich relativ neu. Ich habe noch n — das, was ich gebaut habe, hat sich jetzt noch nicht so wirklich im knallharten Produktionseinsatz bewähren müssen, insofern. Da gibt es mit Sicherheit Fallstricke über die ich bisher selten gestolpert bin. Mal gucken, was gibt es denn, was, wenn ich so überlege, über was bin ich so gestolpert? Eine Sache ist natürlich, man kann in dieser Gesamtdatenstruktur Sachen ändern und dann ist die Frage sowas wie Concurrent Access, wenn zwei gleichzeitig versuchen ein Objekt zu ändern, dann, da gibt es kein klassisches Locking oder keine Transaktion in dem Sinne. Also Transaktionen gibt es nicht. Wenn man an zwei Objekten etwas ändern will, dann passiert das sequentiell nacheinander. Man muss hoffentlich so gebaut sein, dass man, falls das in einen widersprüchlichen State kommt, dass man noch mal getriggert wird und das dann ganz biegt oder, wenn zwei gleichzeitig versuchen etwas zu ändern, dann, der erste gewinnt und beim anderen knallt es, da kommt zurück _das Objekt wurde in der Zwischenzeit geändert_ und da würde dann der klassische Retry-Mechanismus wieder einspringen, dass der dann sagt okay ich gebe auf und eine Sekunde später versucht er es noch mal, liest es frisch und dann hat hoffentlich nicht noch mal dazwischen was gelesen. Also es ist halt, ja du hast die klassischen Probleme eines Distributed Systems mit irgendwie State-Management im weitesten Sinne—

R1: Bloß auf Konfigurationsebene jetzt noch?

I9: Genau.

R1: Wie werden denn Konfigurationen bei euch im Team kommuniziert? Also wenn ihr jetzt eine neue Konfiguration anlegt oder so oder änderst eine.

I9: Den Anwendungsfall, dass jetzt wirklich, dass wir jetzt an was konkret gearbeitet haben und plötzlich gab es ein neues mandatory Setting oder sowas, fällt mir jetzt tatsächlich nicht ein, dass wir das schon mal hatten. Hab meistens bisher an, so ein bisschen an anderen Ecken gearbeitet als meine Kollegen gerade aktuell arbeiten. Beziehungsweise man hat sich von vorneherein koordiniert wie man Sachen bauen will. Wir haben jetzt kurzem haben wir etwas refactort, das war in einem Operator und jetzt sind es zwei, aber da haben wir uns vorher überlegt okay der eine liest von dort und dort und der schreibt dann dafür sein Ergebnis wieder dort und dort hin und der andere liest das dann. Darum haben wir uns das von vorneherein überlegt, wie der Handover quasi stattfinden wird und das hat auf magische Art und Weise sogar einigermaßen funktioniert. Also das war okay. Also in gewisserweise trifft es natürlich, spielt das auch in diese Dokumentationsfrage, die wir vorhin hatten, mit rein. Wenn ich irgendwie pulle und ich sehe an dem Readme-File hat sich was geändert oder an irgendwelchen, diesen Schema-Deklarationen oder so, dann würde ich auch einfach mir den Diff angucken.

R1: Werden bei euch denn bei Code-Reviews auch Konfigurationsfiles gereviewt?

I9: Hat mich bisher nicht wirklich betroffen. Also Konfiguration, sowas wie, um mal auf das Datenbank-Beispiel zu kommen, einfach welche Datenbank gibt es in dem Gesamtsystem. Das war immer was, was für mich schon da war. Das hat mich — ich war nicht derjenige, der eine neue Datenbank angelegt hat oder sowas, sondern ich habe die nur benutzt. Was für uns schon eine Rolle spielt sind diese Schemas. Also die Schema-Deklarationen für Konfiguration. Das wird Git-versioniert wie alles andere auch, wie unser Code auch. Das sind irgendwelche YAML-Files aus Gründen ist es bei Kubernetes, ist der kanonische Weg, dass man Sachen mit YAML ablegt. Und die sind mitversioniert, liegen direkt neben den Go-Files und haben den gleichen Lebenszyklus, wie der Code. Und unterliegen damit auch den Codereviews.

R1: Welche Kriterien habt ihr denn und zu welchem Zeitpunkt integriert ihr denn Konfigurationsoptionen in eurem Code? Dass dann irgendwas halt konfigurierbar ist.

I9: Ich würde jetzt sagen bei der Entwicklung, aber das ist wahrscheinlich eine zu allgemeine Aussage.

R1: Genau, also wann entscheidet ihr, dass das jetzt mal konfigurierbar sein kann und nicht—

I9: In gewisserweise ist es bei uns vorgegeben, weil die Soft— oder unser Ziel ist, wir wollen unsere Software in der Cloud ausführen. Und die Software selbst, wenn es total sinnvoll ist sie zu ändern, können wir sie auch ändern, aber das Gros der Funktionalität wollen wir _as is_ benutzen. Insofern müssen wir das umsetzen, was die Software, die wir ausführen wollen, von uns verlangt. 43:06 Also das sind offensichtlich die, die offensichtlichen Konfigurationsoptionen, die wir irgendwie bedienen müssen. Insofern, das ist etwas, was auf jeden Fall vorgegeben ist. Was wir selbst exposen wiederum an zum Beispiel unsere Kunden, die so eine API callen — ich glaube die Frage hatten wir vorhin schon mal, was davon wir exposen, oder —  

R1: Ja ne, aber nicht — das war nicht was, ja genau, aber warum, also was sind die Kriterien das anzulegen. Also gut, weil es der Kunde will, aber es kann ja auch sein, dass es sein kann, weil wir jetzt irgendwie Monitoring machen wollen oder sowas.

I9: Ach sowas, ja. Genau, also es gibt bestimmte Sachen, die einfach die Software, die wir ausführen schon von uns verlangt. Dazu zählt auch sowas wie, sie will gerne Metriken wegschreiben. Wo schreiben wir Metriken hin? Müssen wir eine URL hinschreiben, das ist glaube irgendein Graphite oder irgendsowas ist das, irgendso ein Metriksystem. Dann kann dieses System, was wir deployen, das spricht dann spricht dann mit diesem anderen System und schreibt seinen Krams dahin. Ist wieder die Frage, wo läuft das wiederum? Und das ist so ein klassischen Infrastrukturthema: Wie steckt man Sachen zusammen? Datenbank ist natürlich der nächste Anwendungsfall. Authentication hatte ich vorhin schon mal angesprochen, das ist auch so ein Drittsystem und wir haben noch andere Datastores, wo wir irgendwie transiente Daten, wie Warenkörbe oder sowas hinterlegen. Das ist eine andere Art von Datastore, der — wo das Shopsystem wissen muss, wo schreibe ich oder wie spreche ich mit dem Ding. Ich glaube ich bin schon wieder an der Frage vorbei, oder?

R1: Ja, so ein bisschen. Ob ihr irgendwie so Richtlinien habt, wo ihr vielleicht sagt in Zukunft könnte man das vielleicht anders machen, deswegen baue ich jetzt mal hier eine Option ein. Also habt ihr so ein Gefühl — kann ja sein, dass es bei euch einfach so ist wir machen nur das optional, was uns vorgegeben ist und nichts anderes, aber—

I9: Also ganz nach — also quasi als API für den Kunden, die wollen wir tendenziell so schmal halten wie möglich, damit wir selbst viel Raum haben Sachen zu reworken oder zu ändern oder — also das ist das eine. Und für uns intern, wirklich Richtlinien haben wir nicht. Wir lassen halt good Judgement walten von was wissen wir, was steht auf der Roadmap, was wird irgendwann sowieso mal änderbar sein müssen, dann bauen wir jetzt vielleicht das schon ein, auch wenn es aktuell dann, der eigentliche Wert vielleicht trotzdem erstmal immer der gleiche ist, aber dass man es schon mal umbiegen könnte, sowas. Haben wir aber wirkliche Richtlinien oder was bei uns im Team keine.

R1: Wie viel Aufwand ist es denn bei euch eine Konfigurationsoption einzubauen? Also richtig beim Implementieren und so weiter.

I9: Die Frage ist, muss man eine Art Migration machen. Also ist es quasi ein neues mandatory Toggle, dann muss man natürlich irgendwie zusehen wie alle die bisher schon laufen, also keine Ahnung alle Shopsysteme, die wir schon haben, wie konfiguriert man die entsprechend, dass sie das mandatory Toggle auch haben. Ansonsten würde es ja nicht funktionieren. Bei optionalen Sachen ist es natürlich einfach. Also tendenziell baut man die Option ein und wenn es irgendwie geht ist der einfachste Weg, man legt einen Default mit dahinter und dann kann man sagen _okay, man kann es umschreiben und per Default ist es das und das_ und dann überlegt, was hoffentlich sensible ist. Das hängt natürlich von der konkreten Konfiguration ab, ob es etwas ist, was sich ändert, was tatsächlich für jeden verschieden ist, oder ja, fällt mir jetzt keine wirklich allgemeingültige Aussage ein.

R1: Und wie hoch kann der dann sein vielleicht im, sagen wir mal im worst Case? Wenn ich jetzt eine ständig änderbare, die überall schon einen Einfluss hat… Also sitzt man dann einen Tag dran, oder eine Woche oder vielleicht einen Monat oder sowas?

I9: Kommt jetzt ein bisschen darauf an, wo die Konfiguration ist. Wenn wir wieder über Kubernetes sprechen, wäre das wahrscheinlich relativ schnell gemacht. Da gibt es auch wieder, würde man dann auch wieder so eine Operator haben, der lauscht auf die Objekte und würde feststellen, da fehlt ein Configuration Property und würde das dann automatisch in allen ergänzen. Die Operator funktionieren auch so, die lauschen nicht nur auf Änderungen — also die werden gestartet und lauschen dann nicht nur auf Änderungen, die dann kommen, sondern beim Start gehen die immer erst mal durch alle Objekte durch, die schon da sind. Das heißt damit kann man auch relativ einfach sowas wie Migration machen. Da könnte halt — man würde, angenommen es gäbe einen Operator, der hat Versionsstand n und dann kommt die Version n+1 und die hat einen neuen mandatory Konfigurationswert implementiert, der würde bei seinem Startup automatisch durch alle Objekte durchgehen, würde bei allen feststellen, da fehlt was und dann irgendeine Art von Logik invoken, was auch immer das, keine Ahnung, vielleicht spricht er mit einem Drittsystem und holt sich einen Wert oder was auch immer. Wie aufwändig das ist, hängt natürlich von dem konkreten Fall ab, was zu tun ist, aber so prinzipiell, so vom — der Mechanismus selbst mit dem wir arbeiten, macht uns das relativ einfach. Also ich würde mal sagen der Boilerplate drumherum, den kriegt man locker in einem Tag hin.

R1: Okay und der andere Fall? Wo es jetzt dann nicht im Kubernetes ist?

I9: Kann ich wenig zu sagen. Das habe ich bisher nichts mit zu tun gehabt.

R1: Wie viel Aufwand ist es denn eigentlich so eine initiale Einrichtung, was ihr auch vielleicht gerade ja auch ein bisschen macht, einer Konfiguration für Tools, Frameworks und Infrastruktur denn zu schaffen, dass initial mal alles so läuft?

I9: Ist prinzipiell mega viel Aufwand. Dafür gibt es natürlich sowas, wie unser Schwesterteam, deren eigentliche Aufgabe ist, diesen mega Aufwand kleiner zu machen. Also das ist quasi ein eigenes Team, was nur sich diesem Problem widmet, was sich hauptsächlich um initiale Einrichtung und auch in gewisserweise dann auch um fortwährende Updates, aber was diesen ganzen Bootstrap-Prozess sozusagen von ich habe mal irgendwie einen nackigen AWS-Account geklickt bis jetzt könnte man da Shopsysteme starten, das dazwischen abdecken soll. Also das ist sehr viel Aufwand. Das rechtfertig ein eigenes Team.

R1: Wenn es so Versionsänderungen gibt, zum Beispiel, also wir haben immer das Standardbeispiel Spring Boot 1 auf 2, da haben sich Konfigurationsoptionen geändert und so weiter, ist das auch viel Aufwand da irgendwie das nachzuziehen, oder die ganzen Konfigurationen zu ändern oder valide zu machen?

I9: Das kommt natürlich so ein bisschen darauf an, ob die, wie der Lifecycle einmal der konfigurierten Appsachen ist und der die die Konfiguration bereitstellen. Wenn man jetzt zum Beispiel sagt, keine Ahnung, wir ändern die Version unseres Microservices, aber die Art und Weise, wo die Clusterkonfiguration, wie der Microservice ausgeführt wird, liegt irgendwo ganz anders. Dann muss man da natürlich eine Art Handover herstellen, sodass man von einem validen Gesamtsystemzustand in einen anderen validen Gesamtsystemzustand geht. Da kann man ja einfach die Version des Microservices anheben und die Konfiguration anzupassen. Wir benutzen dafür hauptsächlich, oder so, für zum Beispiel so Testszenarien oder sowas, können wir das über Featurebranches zum Beispiel machen. Ich könnte jetzt zum Beispiel sagen ich baue einen Operator von mir, mache einen Featurebranch, der hat dann Version 08/15-Featurebranchname-Snapshot und dann könnte man zum Beispiel sagen wir haben ein Repo, wo die, es gibt ein Repo das heißt, da gibt es etwas, das heißt API-Stack. Das sind so die Gesamtmenge an Operators, die man braucht um unser System zu betreiben, werden da so zusammengezurrt und da könnte ich sagen — oder zum Beispiel das Beispiel, was ich vorhin hatte, das wir aus einem Operator zwei gemacht haben, das ist der Punkt an dem das zusammenläuft. Da hätte man dann einen Branch in dem _wir zurren das zusammen_ Repo und kann dann beide Änderungen dort machen. Wenn wir sagen okay, statt dem einen großen nehme ich jetzt den einen dazu und den anderen dazu und das lebt dann selbst wieder als ein Branch und kann man als eine Änderung ausrollen.

R1: Ist das ein Tool von euch oder? Dieses API-Stack.

I9: Das heißt nur so. Oder diese Entität heißt so. Das Tool, was wir dafür benutzen ist Helm. Hätte ich vielleicht auch erwähnen können. Helm bezeichnet sich als der Paketmanager für Kubernetes. Das ist im Prinzip sowas wie kubectl mit Templating. Also das war auch das, was ich vorhin meinte mit diesem Templating-Mechanismus. Man kann Templates schreiben, dann kann man sagen ich habe ein Volume und einen Pod und einen Service oder sowas. Schreibt da irgendwelche Templatewerte rein für die Sachen, die variabel sein sollen oder kodiert die Sachen, die hart sind und kann dann dieses Template instantiieren.

R1: Und das ist auch ein Configuration-File praktisch dann?

I9: Genau, also die Konfiguration, die man in diese Templates-Engine reingibt, ist auch eine Konfiguration. Und das ist unser Mechanismus um Sachen zusammenzuzurren. Zum Beispiel eben dieser Schwarm an Operatoren. Den zurren wir mit Helm zusammen.

R1: Und diese Konfiguration liegt im Repo, oder? Die für Helm oder die für Helm-Templates.

I9: Bisher ist es so, dass man diesen API-Stack nur einmal deployen kann pro Kubernetes-Cluster. Der ist, die Sachen, die da drin deklariert sind, sind nicht alle konsequent genamespacet. Das ist nur ein, dieser Deployment-Mechanismus, aber wir benutzen die Templatisierung nicht um mehrere Instanzen des gleichen im selben Cluster zu haben. Aber es gibt, wir haben verschiedene Kubernetes-Cluster. Es gibt einen für, oder es gibt mehrere für während der Entwicklung, dann einen Preproduction und Production und zwischen denen gibt es auch noch mal Unterschiede. Zum Beispiel nur die Production-Umgebung arbeitet mit unserem Authentication-Service, der auch die echten Credentials hat und die anderen gehen auf so ein Testsystem. Das ist zum Beispiel eine Konfiguration, die dort auch einfließt und die umgebungsabhängig ist.

R1: Was ist denn der größte Faktor, der den Konfigurationsaufwand bei euch bestimmt? Was dauert da, was ist der Faktor, der dafür sorgt, dass es so aufwändig ist zu konfigurieren?

I9: Wahrscheinlich das System, was wir betreiben wollen. Das ist halt im Endeffekt mein Job so als Ops-Guy, sind wir dem ein bisschen ausgeliefert, was wir halt tun müssen. Insofern, das ist wahrscheinlich in der Hinsicht eine ganz andere Perspektive, als das wahrscheinlich bei BX ist, der halt tatsächlich das System baut, was dann konfigurierbar ist und wir müssen irgendwie mit mehr oder weniger mit klar kommen, was die uns über den Zaun werfen. Ganz so ist es nicht, aber so vereinfacht gesagt. Wir können auch, also was wir auch machen ist, für Sachen wo man feststellt, bestimmte Sachen, die in unseren First-Party-Datacentern funktionieren, funktionieren in unserer Public Cloud nicht. Zum Beispiel Multicast geht nicht, wenn du, also das nutzt halt irgendwie auf Ethernet-Ebene so Broadcastmechanismen, die in so virtualisierten Umgebungen nicht da sind und nicht funktionieren. Dafür braucht man einen anderen Mechanismus. Also es gibt schon Sachen, die wir auch zutückfließen lassen, die wir in unserem Team entwickeln und in das Produkt, was wir betreiben, das ändern wir auch, so dass wir es besser betreiben können. Braucht auch wieder eine eigene Konfiguration. Da muss man dann sagen hey, wir wollen anderes Messaging benutzen und hier sind deine Credentials um stattdessen mit dem Messaging von Google zu sprechen zum Beispiel. Also es gibt da so ein bisschen bidirektionalen Flow, aber das betrifft wenige Sachen. Die meisten Sachen nehmen wir as is.

R1: Benutzt ihr eigentlich auch Konfigurierbarkeit um nicht-funktionale Eigenschaften, wie Performance zu tunen?

I9: Ja.

R1: Und — sehr schön — wie sieht das denn aus? Also tut ihr euer, also ändert ihr häufig Konfiguration dafür und wie wichtig ist das?

I9: Das geht ehrlich gesagt gerade erst los. Wir haben halt angefangen mit diesen schon beschriebenen Sandboxen, was halt so relativ kleine Entwicklungsumgebungen sind und wir wollen perspektivisch natürlich all unsere Umgebungen, also auch echte Productionsysteme, die ganz andere Performance-Charakteristika haben, wollen wir auch mit der selben Plattform und der selben Technologie und der selben Logik und alles wollen wir das betreiben können, so dass es im Endeffekt aus Kundensicht oder aus — naja, der Kunde wird das nicht selber einstellen —, aber aus derjenige, der eine Anfrage an unser System macht _fahr mal einen Shop hoch_, der sagt dann das ist von der Art Production. Und daraus sollten dann bestimmte Sachen abgeleitet werden. Ich weiß nicht genau in welche Richtung, ob man dann auch noch sowas machen würde wie, der Kunde ist jetzt _Enter your T-shirt size here_, dass da irgendwie S, M, L oder irgnendsowas oder ob man komplett uns darauf verlassen, dass wir herausfinden, wie man Autoscaling macht, so dass das auch robust genug ist. Das ist noch nicht entschieden, ob dem quasi Hints geben sollte oder ob das System idealerweise — idealerweise sollte es sich selbst konfigurieren, aber ob das robust genug ist müssen wir noch herausfinden, aber es gibt auf jeden Fall Sachen, die konfigurierbar sind und Einfluss auf non-functional Requirements haben.

R1: Gehen wir zu Konfigurationsfehlern über.

I9: Da war doch letztens was irgendwie von Cloudflare (https://new.blog.cloudflare.com/details-of-the-cloudflare-outage-on-july-2-2019/). Die haben irgendwie so einen Regex falsch gesetzt und dann war das halbe Internet irgendwie — das war irgendwie vor ein paar Tagen, da war irgendwie das halbe Internet tot und betroffen waren alle, die Kunden von Cloudflare waren und Cloudflare hat irgendwie eine Konfigurationsproperty falsch gesetzt und dann — […] das war erst irgendwie vor ein paar Tagen.  

[…]  

R1: Stellt die Konfiguration euch denn bei Systemen, Tools und Frameworks und so weiter vor Probleme?

I9: Ich weiß nicht so richtig, wie ich darauf antworten soll, weil was wir bauen ist halt noch nicht — also ich werde nicht nachts rausgeklingelt wenn bei uns irgendwas klemmt, sondern im schlimmsten Fall schreie ich rüber zu meinem Nachbarkollegen und dann gucken wir mal zusammen rein. Also wir sind in einer Phase in der es zu erwarten ist, dass Sachen brechen, weil wir noch daran schrauben. Idealerweise ist es natürlich so, dass, oder es ist irgendwie so gebaut, dass Fehlkonfigurationen nicht erlaubt werden. Dass man, keine Ahnung, zum Beispiel whitelistet was sind denn valide Werte oder wenn jemand bestimmte Ranges für Zahlen angibt oder sowas. Irgendein Potential, dass man irgendwie foobar als Hostname für irgendwas hinschreibt und dann funktioniert das nicht, hat man natürlich immer. Weiß ich gar nicht, mich selbst, seitdem ich in meinem Team bin, fällt mir jetzt gerade kein Beispiel ein, wo ich mir, also neben der typischen Entwicklertätigkeit natürlich, dass man mal was probiert und das funktioniert nicht auf Anhieb oder man fummelt sich auch mal was kaputt, aber das ist jetzt typische Entwicklungsseiteneffekte, das würde ich jetzt nicht als wirklich _das hat mich jetzt irgendwie eine Nacht gekostet_ oder so beschreiben. Also ich sehe das Risiko auf jeden Fall, war aber noch nicht davon betroffen.

R1: Was sind denn deiner Meinung nach die schwerwiegendsten Probleme im Zusammenhang mit Konfiguration, die auftreten können?

I9: Miskonfigurationen. Na die Frage ist natürlich einmal, _wer_ darf etwas ändern. Das ist zum Beispiel schon mal eine Frage, also da spielt irgendwie Security eine Rolle um zu vermeiden, dass irgendjemand, der vielleicht keine guten Absichten hat — also das ist ein Thema. Das versuchen wir so ein bisschen mit role-based Access Control und sowas da Einschränkungen zu machen. Ansonsten, man darf natürlich nichts Falsches reinschreiben, das war das, was ich gerade schon gesagt habe. Dafür sehen wir halt idealerweise zu, dass möglichst wenig händisch einzustellen ist. Das meiste sollte halt möglichst automatisch provisioniert werden und sich selbst mit irgendeiner Art, man sagt Service-Discovery oder sowas, sich selbst publik machen _Ich bin da und das ist mein Hostname_ und der wird halt irgendwie mechanisch da irgendwie eingetragen ohne, dass da jemand sich abtippt und dann einen Typo reinmacht. Also Automatisierung ist — na gut, du hast nach Problemen gefragt, das ist die Lösung. Naja. Keine Automatisierung ist ein Problem, sagen wir es so.

[Unterbrechung]

R1: Genau, ein schwer zu konfigurierendes Tool oder Framework?

I9: Mir fällt ein gutes Beispiel ein von meiner alten Firma. Also das ist nicht meine aktuelle Rolle. In meiner alten Firma war ich in einem Team und wir haben die Build- und Deploymentautomatisierungstools gebaut. Das war ein ähnliches System, irgendwie großes monolithisches System. muss irgendwie jede Menge Javacode kompiliert werden in der richtigen Reihenfolge irgendwie zusammengesteckt werden. Dann Deployment ist irgendwie Zip-Files auspacken und Placeholder ersetzen oder Properties-Files setzen oder verschiedene Arten von Files, in Files rumfummeln und das irgendwie alles an die richtige Stelle legen und dann noch paar Executable Bits setzen und hoffentlich fährt es dann irgendwie hoch und da haben wir wieder relativ ähnliche Probleme wie man sie vorhin hatten, dass du sagst es gibt einmal Buildtime-Konfiguration und dann Deployments, wo liegt die Datenbank und Build-  und Deploymenttooling ist natürlich ein cooler Kandidat, weil alle Entwickler müssen das benutzen. Das ist jetzt nicht, dass du sagst du trainierst halt deine drei Experten, die dort irgendwie die magischen Knöpfe drücken und die wissen das dann wie das funktioniert und dann ist gut, sondern du musst _jedem_ erklären wie es funktioniert. _Jeder_ muss das verstehen und jeder muss das auch tagtäglich benutzen, da kommt er nicht drum rum. Entsprechend groß war natürlich auch so ein bisschen der, ja das Potential, das Sachen schiefgehen und dann haben wir uns vielleicht auch, ja, nicht auf Anhieb alles mit mega guten Fehlermeldungen versehen und nicht alles war so mega intuitiv beim ersten Wurf. Das war halt irgendwie so, also in gewisserweise ein Greenfield-Approach, wir haben tatsächlich so alles wie man Code zusammensteckt und so, diesen Teil komplett neu gemacht. Die Software um die es ging, das war die gleiche, aber alles drumherum haben wir komplett neu gemacht. Ja, das war halt ein großes (?02:17). Konfiguration spielte auch eine zentrale Rolle, das ist halt so das, was der — in unserem Fall war der erste Stakeholder mit dem wir zu kämpfen hatten, waren die Inhouse-Entwickler und ja, da hat das Telefon oft geklingelt. Wir hatten uns da versch— so rückblickend muss ich auch sagen, wir hatten uns damals ein Tool hatten wir Gradle genommen und Gradle benutzt Groovy als DLS. Und idealerweise schreibt man das so, dass da überhaupt kein Code drin ist. Kein For-Each, kein While, kein If, kein irgendwas, sondern du kannst einfach schreiben geschweifte Klammer auf, Name ist gleich foo und Port ist gleich 0815 oder kannst irgendwie, wie eine Art Propertiesfile, so komplett deklarativ schreiben. Das war unsere erste Idee wie wir das machen würden. Dann haben wir festgestellt irgendwie kapieren die Leute das nicht, das war denen zu kompliziert. Dann haben wir irgendwie versucht zu vereinfachen. Dann haben das getemplatet, haben irgendwie gesagt, wir haben jetzt ein Propertiesfile, da musst du ein Subset dessen, was du brauchst, also das Subset dessen, was du als Entwickler wirklich tatsächlich ändern musst, das kannst du in dem Propertiesfile und wird daraus dieses andere File generiert. Das hat dann wiederum zu Verwirrung geführt, was ist jetzt wo und wie korrespondieren die zwei Files zueinander. Das war alles so ein bisschen, naja, und in gewisserweise auch dem geschuldet, dass das System, was konfiguriert werden musste auch zu kompliziert war. Also das hat dann selbst auch irgendwie — da gab es das eine Propertiesfile, da stand irgendwie der Datenbank, die Datenbankverbindung drin, im anderen stand drin auf welchem Port soll das lauschen, für einkommende Request und in einem anderen File steht irgendwie wie ist dein Fully Qualified Domainname, den du dann für URLs rausgeben — das stand alles irgendwie kreuz und quer auch in verschiedenen Files. So nachträglich denke ich mir, das beste wäre es gewesen, wenn unser Deploymenttooling fast gar keine Konfiguration gehabt hätte und man einfach ein Propertiesfile reincopypastet in das Zielssystem und das liest das einfach direkt aus. Dann hast du ein File und Propertiesfile ist eine flache Liste, das verstehen irgendwie die meisten Entwickler. Also gerade so Java-Entwickler, dem kannst du mit Propertiesfiles irgendwie kommen und dann stehen da halt zehn Properties drin und für acht gibt es vielleicht sogar ein Defaultvalue und das wäre irgendwie eine coole Lösung gewesen und wir haben uns für die more sophisticated Variante entschieden, die auch für andere Szenarien ihre Berechtigung hätte, aber für _ich will als Entwickler mal was hochfahren_, das ist halt ein anderes Szenario als _ich will es wirklich produktiv betreiben in einer geclusterten Umgebung_ und so. Und ja, da gab es viel Reibung.

R1: Ist eigentlich bei euch, wenn ihr jetzt die Konfiguration von interagierenden Tools und Frameworks problematisch. Also wenn das eine konfiguriert und das interagiert mit dem anderen. Ist das problematisch oder ist das?

I9: Wollen wir bei irgendeinem Beispiel bleiben.

R1: Jaja, Beispiele sind gut.

I9: In der Kuberneteswelt würde ich sagen ist es relativ gut gelöst dadurch, dass man halt relativ klar definiert hat, welche Schnipsel Logik hören auf welche Daten und produzieren welche anderen Daten. Das ist halt so, wenn man das mal einfach nur so als Black Box betrachtet, so die lesen irgendwas und schreiben irgendwas. Und jemand anderes liest dann vielleicht das Geschriebene und das ist dann so eine Art Kettenreaktion. Da hat man das einigermaßen definiert, wie so die Kollaboration des Gesamtsystems ist. Ein anderes Beispiel wo es nicht gut funktioniert hat, war ja das, was ich gerade beschrieben habe, dass man gesagt hat, wir haben irgendwie ein Propertiesfile und templaten daraus ein anders und dann gibt es aber auch so einen komischen Abstraktionsmismatch, dass man sich wundert, warum funktioniert das eine in dem einen und dem anderen kann ich das aber nicht einstellen. Und das war so ein Fall — ja, hab jetzt nicht spontan eine gute Lösung, wie man das stattdessen hätte machen sollen, aber ja. Also gerade wenn es irgendwie technologieübergreifend ist oder so, gibt es da immer Potential, dass da Sachen sich unerwartet verhalten.

R1: Was sind denn für dich Konfigurationsfehler und wie unterscheiden die sich von normalen Bugs?

I9: Na erstmal, die Frage ist, der Debuggingprozess bis man weiß woran es wirklich liegt, ist wahrscheinlich relativ ähnlich. Man merkt halt irgendwas verhält sich komisch und versucht dann zu graben und zu graben und zu graben und irgendwann merkt man dann entweder da ist ein Bug in meiner Logik oder meine Logik verhält sich genau richtig, aber liest einen falschen Wert oder sowas. Insofern bis dahin ist es wahrscheinlich relativ ähnlich. Die Frage ist natürlich wie man dann damit umgeht oder wie man es löst. Bugs sind halt tendenziell — oder Konfiguration ist halt eine Art von Daten und Bugs sind tendenziell, die sich auf Logik beziehen. Das ist wahrscheinlich so der große Unterschied. Also eine Konfigurationsänderung, also wenn es einen Konfigurationsfehler gibt, der Probleme nach sich zieht, würde man die Konfiguration wahrscheinlich ändern und das ist ja eine Datenänderung, die — kommt drauf an, wie die Daten zustande kommen, wir haben ja schon über Automatisierung gesprochen oder so. Vielleicht auch irgendwelche Änderungen im Git oder so nach sich zieht. Oder vielleicht kann man es auch irgendwie händisch machen, aber — ach, eigentlich ist das alles Mist, wenn man irgendwie händisch Zeug macht. Das fetzt nicht. Klingt nach einer guten Quelle für Konfigurationsfehler: Wenn man Sachen händisch macht.

R1: Welche Auswirkungen von Konfigurationsfehlern sind denn häufig bei euch? Also vielleicht, weil ja gerade ja — du hast ja vorhin gesagt, dass, dann probiert man was rum. Was sind dann die häufigsten Auswirkungen?

I9: Es funktioniert nicht. Bei Kubernetes ist es häufig so, wenn man sich darauf verlässt, dass Sachen da sind, wenn man auf irgendwas zugreifen will und das gibt es nicht, dann hängt es halt. Dann versucht es das halt dann irgendwann noch mal und versucht es noch mal und tut aber erstmal nicht viel. Eine Sache über die ich letztens gestolpert war, war es gibt nämlich einen Mechanismus, dass man sagen kann bevor ich ein Objekt löschen kann, müssen noch bestimmte Sachen passieren. Und das ist so eine Liste, das nennt sich Finalizers und da schreibt man eigentlich nur eine ID rein. Und die ID ist so eine Art Referenz auf mich selbst. Ich als im Sinne eines Operators und der Operator muss dann schauen, hier wird verlangt, dass gelöscht wird, aber meine ID steht noch drin, dann tue ich was auch immer zu tun ist, zum Beispiel Datenbankuser droppen und nehme dann meine ID raus. Und wenn diese Logik aber einen Bug hat und der diese Objekt nie rausnimmt, kann das Objekt nie gelöscht werden. Und dann hat man so ein baumelndes Objekt rumliegen, was eigentlich ein Ergebnis von buggy Code ist, aber dazu führen kann, dass ein Stück Datenobjekt, was vielleicht auch eine Konfiguration ist, nicht ordnungsgemäß weggeräumt werden kann. Dass man so einen inkonsistenten, hängenden Zustand kommt.

R1: Gibt es denn einen Unterschied zwischen falscher und schlechter Konfiguration?

I9: Ja, denke ich schon. Also ein klassisches Beispiel von schlechter Konfiguration sind Sachen, die zu detailliert sind für den Zweck. Es gibt Sachen wie, keine Ahnung, wenn wir jetzt von unseren Kunden erwarten würden, dass sie auswählen auf welche Datenbank sie gehen. Sagen wir, wir haben irgendwie drei Datenbanken. Welche willst du denn? Na, was weiß der denn? Der hat keine Ahnung, dass auf der einen tausend Nutzer sind und auf der anderen nur zwei. Dann würde man den tendenziell vielleicht lieber auf die leerere nehmen. Das weiß er nicht. Also Sachen, die man nicht wissen, plausibel annehmen kann, dass sie bekannt sind, sollte man nicht konfigurierbar machen. Oder Sachen, die derjenige vielleicht nicht konfigurieren können sollte. So zum Beispiel unsere Kunden sollten gar nicht wissen, was es überhaupt, wie unsere interne Netzwerktopologie aussieht oder sowas. Ja, ansonsten um mal auf das Beispiel vorhin zu kommen, auch so das Konfigurationsformat ist eine Frage. Propertiesfiles kann man einem Java-Entwickler zumuten, einem Businessnutzer vielleicht nicht. Aber keine Ahnung, sowas wie Groovy-DSL hat sich nicht wirklich bewährt. Das ist halt so ein klassischer Fall, wo du eigentlich einen IDE-Support brauchst, der irgendwas hast, was dir dann Autovervollständigung bietet. Ansonsten hast du keine wirkliche Chance überhaupt ein valides File zu erzeugen.

R1: Wenn wir an den Unterschied gehen, zu falscher Konfiguration könnte irgendwie was zum abstürzen bringen oder so. Schlechte vielleicht Performance. Siehst du das auch so, dass es da Unterschiede gibt oder sind das für dich eigentlich schon gleiche, kann man gleich bewerten?

I9: Die Konsequenz ist, dass irgendjemand anruft und in den Hörer schreit. Also häufig hängt es ja zusammen. Wenn du sagst du hast irgendwie schlechte Performance, dann merkst du das spätestens wenn mal ein bisschen Druck auf den Kessel kommt. Und dann ist das Ergebnis inzwischen ist es abgestürzt und die Performance ist zu schlecht als dass es überhaupt überleben kann. In gewisserweise auch marginal. Mit Sicherheit gibt es verschiedene Arten von Fehlermodi. Ein gutes Beispiel bei uns sind wahrscheinlich sowas, wie Fehler, die nur einen Kunden betreffen oder Fehler, die die ganze Plattform betreffen. Keine Ahnung, wenn zum Beispiel eine Datenbank abkachelt, sind halt alle Kunden, die betroffen sind, weg. Oder haben erstmal ein Problem versus Sachen, die doch eher ein bisschen isolierter sind, okay für den einen ist jetzt der Tag echt schlecht gelaufen, aber zumindest der Rest läuft weiter. Das sind Sachen, die schon irgendwie einen Unterschied machen. Das fiele mir jetzt ein, genau. In gewisserweise macht es auch einen Unterschied, ob es jetzt, keine Ahnung, Downtime ist, ist ein großes Problem. Das kann halt auch durch schlechte Performance versursacht werden. Also wie ich schon gesagt habe, der Unterschied zwischen zu langsam und ganz weg kann praktisch nicht existent sein. Versus — was gibt es noch? Datenverlust wäre natürlich ganz katastrophal. Das ist auf jeden Fall noch mal ein Unterschied zwischen in einer Stunde ist es wieder da und die Daten sind ganz weg. So das ist ein großer Unterschied. Das sind Sachen, die man natürlich in der Infrastruktur, wenn man tatsächlich mit dem Filesystem, das da tatsächlich direkt dranhängt oder so, wenn man derjenige ist, der das macht und man hat da einen Bug in seinem Code, dann hängt da gleich relativ viel dran. Ich habe letztens die Logik geschrieben, die Datenbankuser droppt und habe mir dabei auch so gedacht, das sollte nicht durch einen Bug ausversehen getriggert werden. Also da hängt echt was dran. So Datenbankuser droppen, das sollte robust sein.

R1: Hast du denn bereits Konfigurationsfehler erlebt oder kannst du von einem besonderen rekapitulieren. Muss jetzt nicht in deinem jetzigen Team sein.

I9: Um noch mal auf das andere Beispiel mit dem, in der alten Firma mit dem Build- und Deploymenttooling zu kommen, da gab es einen Fehler, der ist immer wieder passiert. Ständig. Irgendwann haben wir uns dann mal was anderes überlegt, wie man den ganzen Prozess ein bisschen anders aufzieht, sodass man den Fehler strukturell vermeidet, aber bis dahin ist der immer wieder passiert. Und zwar, das Gesamtsystem, habe ich ja gesagt, war ein großer Monolith mit irgendwie ganz vielen Komponenten. Und wir haben versucht einzelne Bündel zu machen, die Komponenten einzeln zu versionieren und dann war ein Problem wie stecken wir die so wieder zusammen, dass dann am Ende etwas lauffähiges rauskommt. Und da gab es unendlich viele Fälle, wo das Tooling seine Version nicht richtig eingetragen hat und dann haben plötzlich Sachen gegeneinander versucht zu kompilieren, die ganz verschiedene Versionen hatten und dann fliegt natürlich alles um die Ohren. Das ist unendlich oft passiert bis wir das irgendwann mal ganz anders aufgezogen haben und eins der Resultate war, dass wir auch viele Sachen wieder zusammengeworfen haben, wo wir festgestellt haben effektiv leben die eh zusammen, es macht jetzt relativ wenig Sinn die getrennt zu behandeln. Das ist halt so in einem monolithischen System.

R1: Hast du ja eigentlich schon gesagt, aber wie häufig treten Konfigurationsfehler bei euch auf? Also am Tag ein paar mal oder in der Woche ein paar mal?

I9: Für meinen Entwicklungsworkflow sehr häufig, wobei ich das wie gesagt nicht — das ist ja keine wirkliche Problemquelle. Es ist halt so mein eigenes —

R1: Wenn du das jetzt mal so schätzen würdest. Also was bedeutet sehr häufig? Das ist so ein bisschen…

I9: Das ist jetzt die Frage. Ist ein Konfigurationsfehler ein Ding bis ich es behoben habe, oder zählen alle Versuche mit denen ich versuche es zu beheben auch als noch mal falsch konfiguriert? Das ist halt zum Beispiel ein Beispiel. Also man probiert halt viel rum. Also als Entwickler ist man so interaktiv unterwegs und —

R1: Sind eigentlich auch Konfigurationsfehler, ja?

I9: Sind irgendwie auch Konfigurationsfehler, aber ist jetzt — der Impact ist halt marginal. Da hängt nichts dran. Das ist halt meine Arbeitszeit, aber dass ich nicht alles auf Anhieb mit ein paar mal in die Tastatur, niemals den Backspace-Knopf drücke, sofort hinkriege so, ist erwartet. Insofern, wirklich mit Betrieb und auch Auswirkungen für irgendjemanden außer nur mich alleine, wüsste ich gerade nicht. Ich glaube das betrifft mich in meinem aktuell Job gerade noch nicht. Mal gucken, wenn ich so zurückdenke — wie ich vorhin schon gesagt, dieses, in der alten Firma das Build- und Deploymentdings das ist, da hat mehrfach täglich irgendwie mein Telefon geklingelt, weil irgendein Entwickler geblockt war und sich selbst nicht zu helfen wusste und da musste ich dann hingehen und irgendwie selber Commandline-Magic um das irgendwie zu kitten. Das war sehr motivierend das zu lösen. Um das Problem aus der Welt zu schaffen.

[…]

R1: Gibt es generell Unterschiede bei Konfigurationsfehlern zwischen fachlicher und technischer Konfiguration?

I9: In gewisserweise ist die fachliche Konfiguration etwas, das bei meinem Team von außen kommt. Also in gewisserweise ist es not our problem. In anderer Weise natürlich dann schon, weil wenn es jemand versucht zu beheben, dann müssen wir ihm natürlich auch irgendwie die Mittel in die Hand geben, dass er es fixen kann. Wobei bei uns heißt das halt es gibt eine API um Sachen anzulegen und eine API um Sachen zu löschen. Also man kann Sachen auch wieder — Nutzer können Sachen auch selber wegräumen, insofern, das ist für uns relativ simpel.

R1: Wie geht ihr denn typischerweise vor um Konfigurationsfehler zu finden und zu beheben?

I9: Naja, finden ist halt, wie ich vorhin schon gesagt habe, so die klassischen Debuggingsachen so. Man wundert sich, irgendwas klemmt und man hat vielleicht gar keine konkrete Idee wo. Kommt halt immer auf das Tool drauf an. Wenn du jetzt — bei Kubernetes würdest du wahrscheinlich irgendwie kubectl und dann versuchen irgendwie in Sachen reinzugucken in so Objekte, okay was steht denn in dieser Configmap von der Datenbank drin, huch die gibt es ja gar nicht. Sowas in der Art. In der alten Firma gab es dann halt dafür andere Files. Da gab es dann irgendwie so ein so ein Propertiesfile, wo so Umgebungskonfiguration drin sind pro Entwicklungsumgebung. Also man konnte auf einem Rechner mehrere Entwicklungsumgebungen haben und so verschiedene Versionen und so. Aber jede Umgebung hatte so ein File, wo dann drinstand dein Datenbankschema, Username ist blablabla und sowas. Da hätte man klassischerweise reingeguckt und wie gesagt, das war halt das Quellfile aus dem dann templatisiert wurde. Jedenfalls musste man was an dem Templatisierungsmechanismus irgendwas, vielleicht buggy war, wenn man den Verdacht hatte, musste man schon, okay was wird denn aus diesem Propertiesfile, was wird daraus generiert? Stelle dann fest, huch, das Template stimmt gar nicht oder vielleicht wurde der Templatisierungsprozess nicht aufgerufen, das ist ja noch ein outdatetes File obwohl da eigentlich etwas anderes drinstand. Muss man sich dann halt so Stück für Stück durchhangeln. Ja, klassische Debugging—

R1: Macht ihr dann auch Google und StackOverflow auf um irgendwas zu fixen, oder?

I9: Ja, das betrifft halt nur Fremdsysteme. Wir haben halt für unsere internen proprietären Sachen gibt es natürlich keine Antworten auf StackOverflow. Wenn man den begründeten Verdacht zur Annahme hat, dass das Tool was wir benutzen sich vielleicht unerwartet verhält, ist das auf jeden Fall mit dabei, ja.

R1: Und Kollegen sprechen?

I9: Ja, doch das mache ich auch. Also klassischerweise Doku lesen, Kollegen fragen.

R1: Welche Strategien habt ihr denn um Konfigurationsfehlern vorzubeugen?

I9: Na, in gewisserweise hatte ich das schon so ein bisschen angesprochen. Wir versuchen irgendwie viele Sachen zu automatisieren. Möglichst wenig, dass da irgendjemand händisch irgendwelche IP-Adressen eingeben muss oder sowas. Das schreit nur danach, dass man sich vertippt. Viel Automatisierung. Verifikation. Dass man guckt, ist das überhaupt — also als der Konsument der Konfiguration — ist das plausibel oder habe ich alles, was mandatory ist, was ich brauche und wenn nicht, haben wir halt diesen Mechanismus, dass temporäre Miskonfiguration hoffentlich einfach nur dazu führt, dass nichts passiert und sobald das dann konfiguriert oder korrigiert ist, dass es sich selbst heilen kann.

R1: Okay, jetzt sind wir beim letzten Teil, (?22:16) Verbesserungsbedarf. Jetzt kannst du dir wirklich vorstellen du hättest jetzt ein paar Wünsche in Richtung Softwareentwicklung frei und ja, was würdest du dir denn zum Beispiel wünschen bezüglich einer guten Dokumentation von Konfiguration?

I9: Ja, Beispiele. Das erste was mir einfällt sind Beispiele. Ich merke gerade so ein bisschen — ich habe jetzt angefangen Go-Code zu schreiben und vorher habe ich Java gemacht und man kann jetzt über Java eine ganze Menge schimpfen. Dass irgendwie alles so ein bisschen, dass man ganz schön viel Tipparbeit machen muss, aber die Dokumentation von Java — hat jetzt relativ wenig mit Konfiguration zu tun, aber so generell Dokumentationsthema — ist sehr gut. Die sagt einem halt für jede Methode, die man aufrufen kann, okay der Parameter ist für das, der Parameter ist für das. Das sind typische Werte. Ein Beispiel eines Methodenaufrufs. Auch sowas wie, das wird niemals Null zurückgeben oder hier kannst du Null reinschreiben, oder das wird Null zurückgeben wenn das und das ist, sowas. Also so Nullability oder optionale Sachen sind so, das ist da echt explizit dokumentiert. Das steht immer dran, das darf nie Null sein oder das kann Null sein und dann passiert das und das so. Das ist in der Hinsicht sehr explizit und so die ganzen typischen Edgecases über die man stolpern kann, sind dort tendenziell bedacht und schon ausformuliert. Und das ist ein Beispiel, was ich zum Beispiel bei der Doku von Go nicht habe. Da steht dann halt drin ja, das macht das und das. Aber ja, was macht es denn wenn dort Nil reinkommt? Das heißt Nil statt Null, aber verhält sich genauso. Was macht es denn dann? Ja, da muss man dann halt durch den Code durchlesen, das steht nicht in der Doku drin. Das wären halt so klassische Sachen. Also einmal Beispiele geben. Nicht nur so abstrakt irgendwie, das muss jetzt ein blablabla, insert technischer Begriff here, sondern mal sagen okay, wie kann es denn konkret aussehen und so Edge Cases abhandeln. So ist das optional, ist das mandatory, wie verhält es sich, wenn es optional ist aber nicht da ist? Was passiert dann? Was für eine Konsequenz hat das? Sowas explizit behandelt zu sehen finde ich sehr hilfreich.

R1: Kennst du aus deiner Erfahrung Beispiele für eine gute Dokumentation von Konfigurationsoptionen speziell? Oder eine schlechte?

I9: Ja, tatsächlich. Mir fällt als Beispiel ein, noch mal auf die alte Firma bezogen, wir haben als Tooling um unser Build und Deployment zu machen, haben wir Gradle benutzt. Und Gradle selbst hat eine ziemlich gute Dokumentation. Das ist so eine Webseite, die kann man sich angucken. Die ist versioniert je nach Gradle-Version, kann man sagen ich habe Gradle-Version bla und dann sieht man die Doku dafür. Und die Dokumentation selber ist, also da ist auch jede Menge Konfiguration. Also Gradle selbst, man kann es programmieren, aber der Großteil der Sachen, die man erreichen will, würde man eher deklarativ machen. Ist also auch eher eine Konfiguration. Und die Doku hat jede Menge Codebeispiele und die haben einen sehr smoothen Move gemacht. Also erstens, die Dokumentation selbst liegt auch im selben Git-Repo wie das Tool selbst, was dokumentiert ist. Und alle Codebeispiele sind als Includes gemacht aus einem File und dasselbe File wird von Unittests bearbeitet. Das heißt die haben automatisierte Tests in ihrem Jenkins, die sagen ob die Code-Snippets, die in der Doku sind noch funktionieren und so Sachen. Weil das ist immer so der Klassiker, man refactort irgendwas und in der Doku steht aber noch ein Beispiel und alle Newbies copypasten das Beispiel, es geht nicht und sie haben aber keine Ahnung woran es liegt, weil ihnen das tiefere Hintergrundwissen fehlt, was sie genau durch die Doku hätten erlangen sollen, aber nicht können. So also das fiel mir als sehr positives Beispiel auf. Die haben sich da viel Mühe gegeben und die haben auch viel investiert, dass die Doku gut bleibt.

R1: Besonders schlechte Doku?

I9: Ja, ich habe jetzt schon die Go-Doku angesprochen so als — ich weiß jetzt nicht, ob es die schlechteste Doku aller Zeiten ist. Die schlechteste Doku aller Zeiten ist natürlich immer keine Doku, aber sie ist auf jeden Fall im Vergleich zu dem, was man von Javadoc gewöhnt ist, nicht so gut.

R1: Wenn du jetzt Kubernetes ansprichst — viel angesprochen hast — wie findest du da die Doku?

I9: Die ist tatsächlich relativ gut. Für jeden Typ von Objekt, den es da geben kann, gibt es einmal dieses Schema, was ich schon erwähnt hatte, das ist so in YAML definiert und für jedes Field gibt es auch eine Long Description. Und daraus gibt es auch irgendwie so eine Website, die so ähnlich ist wie das, was ich von Gradle gesagt habe. Da gibt es halt einen Versionsschalter, kann man sagen für welche Version von Kubernetes und dann steht halt da okay, es gibt diese Typen und wie verhält der sich, welche Konsequenz hat das, wenn ich ein Objekt von diesem Typ anlege? Was ist mandatory, was ist optional? Was ist deprecated, was ist noch beta? Genau, würde ich als eine der besseren bezeichnen.

R1: Okay, welche Verbesserungen würdest du dir hinsichtlich der Konfiguration von Softwaresystemen und Frameworks und Tools wünschen? Also richtig so frei aus dem Bauch heraus. Was dir dein Leben mit Konfiguration verbessern könnte.

I9: Ich finde den Ansatz von — oder was ich sagen kann, den Ansatz von Kubernetes finde ich einen der besseren. Dass man eine Art zentralen Datastore hat in dem Sachen zusammenlaufen, dass man immer weiß okay, wo schaue ich denn auch nach. Dass man nicht erst anfangen muss zu graben okay, wo steht das jetzt? Das steht halt garantiert irgendwo dort. Dass man automatisch darauf reagieren kann auf so Events und dass man auch automatisch Sachen eintragen kann. Also das ist eine der besseren Sachen, die mir aufgefallen ist. Was ich mir darüber hinaus wünschen würde weiß ich gar nicht. Es gibt halt je nach Anwendungsfall wünscht man sich vielleicht mal zum Beispiel, dass es ein festes Schema gibt und für manche Sachen, wo man sagt wir sind noch so ein bisschen am prototypen, wissen vielleicht noch nicht so genau, sagt man okay, wir nehmen einfach eine Map. Da ist jetzt nicht klar deklariert welche Keys müssen da drinstehen. Das ist halt erstmal unstrukturiert. So dieses Spektrum hat man, das kann man beides machen. Tendenziell wird man halt vielleicht eher mit einer Map anfangen und dann irgendwann, wenn das sich konkretisiert hat, dann in ein wirklich strukturiertes Objekt überführen, wo man dann einzelne Fields auch dokumentieren und mandatory, beta, et cetera machen kann. Dieses Spektrum ist nett zu haben, kann es aber auch — es gibt auch die Wahl zwischen flachen Listen oder hierarchisch strukturierten Daten.

R1: Was würde dir denn helfen schneller vielleicht Fehler zu finden, Konfigurationsfehler oder die schneller zu beheben? Gibt es da irgendwas, was dir helfen würde?

I9: Am besten ist es immer, wenn es leicht verständlich ist. Quasi der, wenn sich Datenfluss leicht nachvollziehen lässt. Wen man weiß, okay, diese Einstellung Auswirkung auf X, Y und Z oder umgedreht, wenn Z  gewackelt hat, dann kann das zum Beispiel an X gelegen haben. Solche Flüsse zu visualisieren, das versuche ich auch so ein bisschen mit den Operators, die die Logik sind. Dass man das klug durch Logging macht. Dass man immer Logging sagt, okay, weil jetzt ein Objekt mit dem Namen, und dann schreibt man seine ID rein, angelegt wurde, mache ich jetzt das und das und schreibe wieder die ID hin um so die Verbindung zwischen Sachen herstellen zu können, dass man dann sich von Hopp zu Hopp navigieren kann, wenn man irgendwie auf Fehlersuche ist. Also Transparenz herstellen im weitesten Sinne ist denke ich das sinnvollste, was man tun kann.

R1: Okay und vielleicht noch als letztes, irgendwas was dir hilft irgendwie Konfigurationsfehler vorzubeugen, was es vielleicht noch nicht so gibt oder?

I9: Ist jetzt so ein Unknown Unknown. Ich weiß nicht, was es noch nicht gibt. Ich weiß halt was es gibt und was irgendwie vielleicht eine gute oder eine schlechte Idee ist. Ich weiß, ja, (?30:52) halt irgendwie Konfigurationsfeldern Attribute zu geben. Sowas wie  ist das optional oder nicht. Ist es deprecated oder nicht. Kubernetes sagt auch noch ist das Beta oder nicht. Also ist es ganz neu und vielleicht ändert es sich noch mal oder ist es stable, dann lassen wir es sehr lange Zeit so. Sowas explizit dranzuschreiben, zu deklarieren wo muss man vorsichtig sein und auf was kann sich verlassen. Das ist auf jeden Fall hilfreich. Also falls irgendwie was total magisches um die Ecke kommt, dann würde ich das natürlich auch mal ausprobieren, aber fällt mir jetzt aus dem Kopf nichts ein.
