R1: The goal in this interview is to get the status or practice in the configuration of real software developers. The problem is that in the academic field it is not entirely clear how important, so what role does configuration play in terms of importance in everyday life and what problems exist in relation to configuration. And this interview is supposed to help us to shed light on these things and later ... The problem is that the academy lacks this knowledge of what is done in practice and this series of interviews are supposed to help us find out the real reasons and the real problem and that we can also direct our research in this direction. Exactly, now we will first ask general questions about software development in order to be able to classify you as an interview partner here later and then we come to configuration, what it means to you, what it means for you to understand, configuration errors come next and then I'll say special questions microservice environment if you are there and where there may be need for improvement. Ok, is something still unclear?

I1: No, it fits.

R1: Ok, great. Then I would say let's just start with the first question. Oh, maybe just because there is a pre-interview, a pre-interview before the real interviews, it would be nice if we could also give feedback directly or if your questions are funny, that you can simply discuss it, where we can then perhaps clarify questions can and (R2: (…)) and we can thus improve our questionnaire. Or the structure, etc. Ok. So what domain do you mainly work in?

I1: I am an IT consultant for individual software development and for the software development process in general. And we help customers practically to get from the idea to an executable product.

R1: Ok, if you go a little further now, you would be like that, maybe you are backend developer, DevOps, in the security area, front end development, where would you classify yourself?

I1: I would say now that I come from backend development and that is spreading everywhere, so if you are a pure backend developer, now in the future it will hardly be needed anymore and you will notice in practice, that you have a lot to do with other topics anyway. Which of course is also due to the fact that the back-end frameworks have become better and better. Yes, earlier you could justify full-time jobs, today they are just extremely good and that's why my second topic is DevOps, Continuous Integration, Continuous Delivery, you could even say something like what I read, software delivery Expert. I've read this a few times now as a job title. And at the same time always a little bit of frontend topics that just come in.

R1: Okay, maybe you can just say what frameworks and tools do you usually use? So maybe give five examples or something.

I1: Exactly, so I travel a lot in the Java environment, backend technically with Spring, Spring Framework, Spring Boot, Spring Integration, so I say this whole spring universe. Spring-Cloud, what is so attached to it. And then with related technologies that are used in the backend. So messaging, RabbitMQ, ActiveMQ, Kafka or just databases. Then something like either JDBC or SQL. Sometimes NoSQL databases. Exactly, and hold web services a lot. For connecting frontend or any other software components that are then used or offered by, mostly by other customers and that integrate. And then something like SOAP and REST. That would be the whole backend part and, yes, frontend lately has always been mainly between two, the fight so to speak, between React and Vue.js, whereby I am always for Vue.js because it is quite slim in the introduction, but depends on the customer. And in all of DevOps, continuous integration

R2: What does the fight between two mean?

I1: Well, there are just three big front-end frameworks that are so straight, so if the customers think up a bit, they now have PHP5 application that has grown over the past 15 years and now want a completely new one Start platform. Then you actually always think between Angular, React and Vue.js, these are the big three. And then there are always tables and then they just say that these are our requirements and what we take now and so. If it is now more towards the mobile app, then many are heading towards React because the framework is pretty well developed.

R2: Yes.

I1: But if now, some drive now it comes back to the migration strategy, then they don't start any, so actually everyone doesn't drive a Big Bang and want to integrate their existing application. Vue.js has advantages because I can integrate very well into existing things. Exactly. Yes, and this whole DevOps track is a lot in this infrastructure-as-code tools, something like Ansible. I'm on the road a lot, there are a lot of customers who also have puppets and bosses, but that's older, you have to say and a lot of people migrate to Ansible. And there is a lot with what is flying around: Vagrant, GitLab, GitHub, Jenkins, Travis and so on.

R1: Okay, what's your role in software development?

I1: Mostly you have a lot of hats, in the past that was very strictly separated in the traditional software development processes. Something like, there was the software architect and there was the project manager and there was something else for roles, the QS manager, the test manager, release manager and so on. But due to the ever increasing adaptation of agile development processes, you actually always have relatively small teams that have to cover everything and it is usually the case that the tasks are distributed in such a way, ideally that it also matches their talents and skills. And I can always get very involved with software architecture. Most of the time that's my topic, I can't keep my hands off it. And then there is a lot of software development itself, so simply developer would be such a role. Exactly, and stop this, yes, software delivery expert, where I spend a lot of time on this infrastructure topic, whatever that means to have such classic admin roles and actually to pull them more and more into the team. Because these microservice approaches, which are now being used, aim to ensure that everything is really done in a team, so 'build it, you run it' according to the motto and you can also tell through these quick processes where you are sort of progressing in two-week sprints or something, you get results so quickly that you can’t wait for any infrastructure department that somehow says “oh, you’ve ordered a server, in three weeks you’ll have it regular, but unfortunately, since we no longer have any RAM available in the ESXI cluster, you have the 2 months ”, that just doesn't work, that means you have to pull it in and

R2: What are the roles?

I1: So what is often there are these classic Scrum roles, so Scrum is mostly done somehow, so there were also a few that you can do what I would prefer, but most do Scrum ... if they do Think agile and there is such a product owner, is usually always set, the Scrum master, who pays a little attention to the processes and then there is also, I say, yes, there are people which are more frontend-heavy, so these frontend developers, there are already backend developers, but there are also more and more full-stack developers, then of course there is something like that now comes from professionalism, something like designer, or general experts for a domain and so on, I would rather say that they may now have a focus on testing. So what you used to call a (...) test manager or something.

R1: Okay, maybe last general question: How many years of experience do you have as a software developer?

I1: Now exactly 10, i.e. 10 years of professional experience and if you add a little bit of the dual study to it, you could maybe add 1.5 years, but so 10 official.

R1: Okay, let's go to configuration, now specifically, what do you mean by the term configuration?

R2: First of all, maybe I would reflect a bit on the general category. If you are missing anything.

I1: Oh, the introductory part?

R2: Exactly, so general when it comes to setting the context. Are you missing something? Or is there too much?

I1: No, I think you need a bit of an introduction. What kind of person is that and what ... to be able to evaluate what then are, what is the use of the answer afterwards?

R2: Are you still missing something? So what do you ask someone who wants to start with you or who wants to join your team? Then what do you ask him?

I1: Yes, well, if someone wants to start with me now, of course I also ask a lot about the softer criteria, like somehow motivation for something or why you apply here and something. It's not that interesting here somehow.

R2: More technical stuff?

I1: Exactly, but the technical stuff ... Yes, usually you go deeper, (...) then you ask some details about some technology now. If he says he can somehow do Kubernetes… until vomiting, then just ask “well, how do you set up a network there?” Or something. But I think that's actually quite good in scope. I don't think that should get too long. So I could talk for hours or something, so (laugh). That could certainly be longer with one or the other.

R1: Okay, but was that so clear with role and so on and domain? So you have exactly that

I1: Maybe, so the only thing you could possibly do would be one or two examples. So as ... maybe someone understands role as something else, but in itself I thought it was good, so.

R1: That was answered exactly as you thought. We still have examples, we would have given them.

I1: Okay well, yes.

R1: Exactly. OK. Then it continues ... towards configuration. Yes, in general what do you understand by the term configuration?

I1: Yes, so you can do a little bit, if I look back now, it is always the topic that you can encode a lot, so you can always write everything, the problem is that the software often comes in different versions Contexts are used and then, once in different contexts, that is the topic 1 for which I configure and we can perhaps go into more detail about what such a context would be and the second would be, I don't always have the know-how available to adapt the software. So to adapt the code. It gets lost very quickly, so this know-how gets lost very quickly from a project, from a company. Mostly even with the people who wrote it. So I always joke like that, when you talk about test-driven development and things like that with the customer why you should do it, I always joke that I say, so I actually know in two weeks no longer what I did there, which of course is not * completely * honest, but a large part may then be gone and that's also a reason that I do something configurable, which I would have to adjust anyway anyway ... Exactly, that would be the second aspect and the third aspect is of course if I do something, yes how can I say, there is still a further concept with the Convention over Configuration, which is always a bit misleading because you think okay I'm doing now ... what does that actually mean? But actually that is, so to speak, if you now had software that you cannot configure at all, then you would have configurable software and then that would be a step 3 for me, so I would have * pre * configured software, so to speak. And that is such an important topic, especially in the current software development, actually * the * most important topic when I think serverless or something, that is actually maximally preconfigured.

Exactly. Yes, and of course with the first topic, i.e. these contexts, it is always so, you have most different development environments, from the development environment. So starting from the local development environment, with one yourself on the workstation, on the laptop, to the one where everyone integrates, to a specialist test environment, pre-production environment, as everyone now calls it, to the productive environment. And they usually don't have a database or something like that, but each have their own database, they have their own load balancers, their own ... certificates, their own environment-dependent things and I have to be able to take them into account somehow. So that I can somehow minimally configure a database URL or something. Otherwise the software would be ... So it would be very difficult to somehow get it done.

R1: Okay, how far does configuration play a role in your daily work?

I1: Hm, that's a good question. As I said before, with the Convention over Configuration, what is actually becoming more and more popular, so that I am one of them, I am not sure whether that is just because you want to show something quickly at conferences in five minutes, but in any case ... no, that's a fact that you don't always have an expert sitting around for every problem and that's why the direction is quite good. The problem with this is that this whole convention is still configuration, so it is still, has an impact on the software anyway. So in the code somehow this configuration is used. That means, in case of doubt, I have to be able to get in there and go deep inside. And what was the original question?

R1: How far you are in daily work ...

I1: Oh yes, exactly. And that is exactly the topic, which is probably ... a very high percentage. I would say more than develop. More than programming ... much more than programming. Actually

R2: How much per week?

I1: That's a good question, so I ... so it's probably from the gut, that sounds so much now, but I would say at least somehow 60% or so. Is one actually only to configure.

R2: You said now from the gut.

I1: Well, that sounds so high to me now. I would have to verify that somehow, but (laughs) so I would say more than I develop. But that can of course also be due to my specific role, because of course I am asked again and again about something like that, ah, I somehow have a Docker container here and it doesn't talk to Elastic Search, how do I do that now? That may now be for someone who might be on a development team, so to speak, who now somehow has someone like me in there and who then, as it were, ensures that the whole development runs somehow, so it is clear where I kind of check my code in, which one Development environment i work how i have to do that my code gets to production. If all of that is cleared up for him, maybe he can program more in a given programming language with given frameworks. Certainly, well ... but then that's a lot, let's say this typical, exactly, that was kind of a question, what role do you have, so to speak, I would even want to subdivide those developer roles again, namely in the specialist developers, I say now. So, the really functional functions develop all the time, also know their way better, that is, very often with the customer, in such a way that you have really, very department-related developers who may even come from the department, are extremely good at Knowing professionalism, but not quite as good in all these tools and so on, they don't even want to know how Docker or something works in detail now. They just want a development environment and then, let me say, start coding. And that actually fits quite well with the skill, which we then bring in a bit. Because we have no idea of ​​the professionalism, actually, but so bring this whole technical aspect into it. Exactly.

R1: Maybe a follow-up question. If you see such a Scrum team, it is limited, such a, yes, technical developer per team is necessary nowadays or you can, so how important is the configuration for such a Scrum team now, in your opinion.

I1: I would say that it is very important, so it tries to make the industry less important at the moment by improving the tools you have. So when you think of Serverless, so to speak, you get everything put down and really only have to code. But until that is so far that it is really used in the broad masses, I think it is very important because, so this high proportion of you have to do with the configuration of frameworks, somehow says something about the importance and the many questions that you get in the team are somehow such a degree meter. And as I said, modern software development in the company is very much concerned with the use of frameworks and not so much with any programming language details. That's just ... So when you have these classic ... how can I say? So if you were to ask me any basic things about any programming language, I would probably fail. Through every test. Because I just hardly deal with it anymore. It's really awesome, so ... (laughs).

R2: Write a for loop.

I1: All right, I can still manage it, but ... (...)

R1: Then, back to configuration. If you think about it now, you can configure something in a monolithic system and you can also configure a tool or framework or the infrastructure. What types of configurations you typically deal with. So are you configuring a system, monolith, a monolithic system or rather a system of systems?

I1: This is actually more and more in the direction of systems, i.e. several systems, i.e. monoliths is basically always what is always there with the customer, wherever he wants to go and that means that he makes many of the problem he has right now from that. So just multiply it and then try to somehow reduce it with the things you introduce. So deal with it. It's actually always the same, so this one actually has a huge advantage for this whole topic of continuous integration / continuous delivery, it didn't really hurt so much back then at the monolith so to speak and now it hurts a lot more and that’s why everyone introduces it… automatically, because otherwise you don’t develop anymore. Otherwise only says "How do I actually find errors in my system?".

R2: Are there still several types of configuration? Or really just the two categories?

I1: I think I still hang on ... the question from him (R1) was which specific tools, right? (...) I'm kind of uncertain now.

R1: So I might have thought now, if I now have a database, for example, then I can configure it for myself. That I use. (R1: Yes. Yes.) And then it runs faster or slower for example or something (R1: Oh, yes). And now I have a microservice, where I have to configure a lot of things, what ... does that matter, this one database configuration at all, or doesn't it? Or

I1: Yes, whenever it's broken. So whenever they do. Actually, you could say it casually if the convention doesn't work. So if the preconfigured is not enough, so to speak, or somehow breaks or any errors occur. Of course, that also has the huge big disadvantage that you have, that is, you had the monolith beforehand, you might have had it completely under control somehow, you once saw everything in there. And now you almost have no chance at all, so you actually look into the components rather like a spotlight and are extremely dependent on it, which was always the subject in the past, that in these monolithic applications it was also easy wrote a lot myself. So you just thought up what the database layer looks like now, or the ORM mapper, or because we can do that much better than a thousand open source developers. That is very often, this "not invented here" problem, but it is no longer possible. If I don't open an application now and know "okay, the sources are in` src / main / java` or elsewhere and the tests are in `src / main / test`”, so if I don't know a little bit, that is the default structure, then ... how am I supposed to find out, so if the structure is complete it is important. Is also for all these configurations - exactly, so this structure is extremely important for the configuration, that you have such generally valid folder structures and something, that's where it starts. If I now open any project and then I look in and have a completely cryptic, nested structure in front of me, then I think so "hm". Yes, something like that, if I now use a tool like Maven or Gradle or something, then I just assume that the root `pom.xml` or` build.gradle` is in the root directory. If it were somewhere else now, I would not be able to cope with it and neither would the tools themselves. Because they also assume that. Just like a Dockerfile, I would guess or expect it, too. This is even technically solved in such a way that the Dockerfile cannot be built at all, if not below, it can't always be said to reach up the directories, but only ever deeper. But that was common in the past. Every project had its own structure and there was a developer who knew that and the others just asked him. There is no time for that today.

R2: That means that it is changing so slowly that it is away from the monolithic systems and towards the tools, frameworks and so on (I1: Yes, exactly). Is that still 50:50, right?

I1: Oh, that's a good question. So it felt to me, over 90% microservice architectures, but that's also because I'm always getting involved in that direction. And a lot of what's left is probably the other way around. So that's what is really going somewhere in reality is definitely the other way around. Certainly. (…) And also the big ones, the companies that are always mentioned, that are now promoting a microservice architecture, also come from a monolith. So, shining example is always Netflix. They only had a monolith, it didn't scale and that's why they made microservices. You have to say that to every customer again, so you have that too, the problem? (laughs) Sometimes a well-cut monolith, a microlith or something might be okay. Because you always have to be careful with these, (...), but the microservice story actually means that what I maybe modularized before, I now deploy modularly, i.e. on different servers. And if it is now just docker containers, but that immediately implies a distributed system with corresponding challenges: the network is reliable and all these (…) of distributed (…).

R1: Okay, if you now see the importance of a configuration again, how would you do that (...) the importance in software engineering because, perhaps with such a background again, you have a lesson in teaching mostly not great configurations as a topic. How important would that be for you in software development / software engineering in general?

I1: Well, I would say that the current trend in architecture, in something like microservices, actually makes it more and more important. Because if the things are not configured, somehow vinegar with development, right? It always has to be somehow and the more complex the systems, so the more distributed I say and therefore more complex and the problems that I then, so I then use tools to somehow capture the problems. Such a simple example is if I now start up a spring boot application and it works for itself, then everything is totally simple. As soon as I start booting up several of them, the classic "oh, let's take Spring Cloud". So, and then, yes, okay, let's take Spring Cloud and then each of these Spring Boot applications, where you can then drag Spring Cloud in, suddenly has a properties file no longer two entries, but stop ... 50 \. All configurations. And all there is to configure the tools that are there to make life easier. That is the ... that is exponential growth from two to fifty is so (...) - explosion of configuration things. All of which can break. So that's why I would say yes, it is becoming more and more important. And the higher you go up the level of abstraction, that's now at the server level, so to speak, I distribute myself ... but if I include that now, I have some serverless provider or something, he has the problem underneath. He has a lot of problems underneath and there is probably more that has to play together.

R1: Okay ...

I1: And then there is always the big problem, we probably talk a lot about the software development phase, i.e. the project phase: agile project, budget is there, everyone is looking at the code. What happens when the project ends? Then ... then you go from development to maintenance mode or something, the development team is reduced from 20 people to 2 or so. And then they have to wait for this software. And then the problem gets even worse, because ... all the libraries and so on are still running, so they will, they have some security holes, they have to be updated, otherwise ... and then they have an error. Somewhere. And then we have to do it on our own, somehow 200 microservices or something ... yes, the trend is really to pack every function practically in our own microservice and then ... they have a real issue with it. So then it is definitely the case that configuration is much more important than you might assume in your studies, or something. I hardly had anything to do with it, it was always somehow ...

R2: So you could actually fill an entire lecture over the semester with it?

I1: I would say yes. If you at least link it to the background why it is becoming more and more important and maybe put a spotlight on it, because it is difficult to say, it is because of the microservices, you have to say what is it anyway. That means that there is always a bit of software architecture or whatever happens in software development in general on the market, where is the world going? A little bit, yes.

R1: Okay, yes, are you having problems configuring these systems or tools and infrastructure, frameworks, etc.? So what are the practical ones, first the most difficult problems or the most difficult problem, maybe first and then ... we can go on.

I1: Yes, the main problem is always the integration of multiple frameworks. So that's what is mostly poorly documented. So the tools themselves are poorly to very well documented and as, let's say, a sensible IT consultant, you naturally try to recommend tools to the customer that are well documented so that they can still live with them and then take really just keep the tools out, where you then say "oh, that is no longer maintained, nobody is interested in it anymore, maybe you shouldn't use it" or something, but rather where there are potentially a lot of stackoverflow answers, a lot of blog posts and such . However, what then becomes less is when you say I want to integrate two different tools now, you are often lucky that there is still something here and there, but in the end, the architecture that you then get from the customer build doesn't consist of two tools, but of ... I don't know, right? So those that you might choose yourself for a technology stack, the at least a list of ten things and integrating these ten things is the task and then the ten things have dependencies and dependencies that they can do without that now you know that big just pull it in. If I look at a standard pom from such a spring boot project and click on "effective pom" in the IDE, then I feel very bad because ... it pulls half the Internet into it. That is only when there is a building block wobbling away somewhere ...

R2: What is pom?

B2: This Maven project object model. Diese, wo praktisch beschrieben ist welche ganzen Abhängigkeiten (R2: okay) meine… Und achso genau, und die effective pom zeigt dir auch noch die transienten Abhängigkeiten, also die die deine Bibliotheken dann auch noch mitbringen.

R2: Gibt es dann noch andere Probleme oder wirklich die Integration (…)

B2: Integration, genau die Integration ist ein wichtiges Problem und dann halt wenn, also wenn… also das ist sozusagen das Startproblem wenn ich loslege mit dem Projekt. Und was dann, das geht ja dann, wird ja dann weniger, weil irgendwann habe ich ja mal so einen Stack konfiguriert. Was dann aber viel mehr wird ist genau dieses Thema „irgendwo muss ich jetzt eine Bibliothek updaten“… ich muss sie irgendwie, warum auch immer, also ich brauche neue Features vielleicht von dem Framework, oder es gibt Security-Probleme oder sowas, oder der Support wird, läuft aus von meinem Hersteller, wenn ich nicht diese und jene Oracle-Version einsetze oder sowas. Das ist ja so typisch. Oder auf der neuen Xy-Server-Version läuft nur noch die und die Version, dann muss ich updaten. Und dann ist ja das Problem meistens, dass natürlich, man kennt das ja von sich selber, also dass in einem Framework, was ich mal entwickelt habe vor zwei Jahren, das würde ich ja heute niemals mehr so schreiben. Die API war totaler Crap. Das würde ich heute… ne? Und die war vollkommen inperformant, heute würde ich es komplett anders machen. Vielleicht auch noch in einer anderen Programmiersprache. Und das machen jetzt alle von den ganzen zehn machen das… ungefähr alle… ja, das ist eine gute Frage wann die das machen, vielleicht einmal alle zwei Jahre, sag ich mal einfach, machen die so einen richten Rewrite. So, und dann auch die ganzen transienten Abhängigkeiten, die machen das auch so. Plus… ich habe ja gesagt man versucht immer so… gut dokumentierte Tools zu nehmen, davon sind (.) mindestens… (…) also Bauchentscheidung, aber mindestens 30&nbsp;% der Frameworks werden nicht mehr maintained, das heißt ich muss irgendwann das Framework wechseln. So und, also das ist eigentlich fast genauso schlimm. Ein Upgrade eines bestehenden Frameworks auf eine neue Majorversion würde ich fast genauso schlimm sehen, wie irgendwie ein ganz anderes Framework einzusetzen für ein bestimmtes Problem, weil meistens ändert sich komplett die API oder sie haben intern so viel umgebaut, dass das, was ich eigentlich drüber gebaut habe, nicht mehr funktioniert. Gerade bei mir gestern passiert, ich habe so ein Framework benutzt — Spring Cloud Sleuth — was dafür da ist so Tracing-Informationen durch ganz viele Microservices durch ganz viele Microservices automatisch zu generieren, durchzuschleifen und mir irgendwie für eine Auswertung bereit zu halten. Und da habe ich halt Zeitmessungen drauf aufgesetzt, auf die API. So ein… eigentlich ganz simple Millisekunden, die ich da abgefragt habe. Und die API, die neue, gibt es nicht mehr. Keine Chance. Drei, vier Stunden reinversenkt. Ich war dann irgendwo mitten in der, sie haben halt intern umgebaut, die hatten halt vorher irgendwas selbergeschrieben und dann haben sie jetzt Zipkin, OpenZipkin Brave benutzt und Brave hat das nicht intern und dann steht da halt ganz oft „ja, gibt es jetzt nicht mehr. Das gibt es nicht mehr, das gibt es nicht mehr. Musst du halt das nutzen, musst du da gucken“. Sie haben aber irgendwie oben in ihrer API haben sie ein neues Objekt eingeführt, was irgendwie dann doch nicht das Zipkin nutzt und dann geht gar nichts mehr. Das war irgendwie… das ist so ein typisches Beispiel wo man dann ewig dransitzt und eigentlich… (R1: Ist das jetzt ein Konfiguration) Wobei, das war jetzt kein Konfigurations-, sondern ein API-Problem. Aber Konfigurationsthemen hatten wir dann trotzdem, weil sich auch, wenn sich irgendwas ändert, kann sich ja genauso gut die Konfiguration ändern. Speziell in diesem ganzen Spring-Cloud-Umfeld ist es ja üblich, dass eben genau dieser zwei-Jahres-Rythmus mindestens eingehalten wird und dann alles anders ist und da wurde jetzt letztens gerade erst mit Spring Boot und Cloud 2 wurde der ganze Matrix-API umgebaut, das heißt diese ganzen Infastruktur-Leute, die jetzt darauf aufgesetzt haben, haben jetzt ein Problem, weil es immer komplett anders läuft… (…) jetzt irgendwelche Systemüberwachungen oder so. Das muss man ja auch alles aufsetzen und irgendwo dranhängen damit irgendwelche Admins vielleicht nachts rausgeklingelt werden wenn der Bestellprozess nicht mehr funktioniert oder so und das ist dann meistens nur ne Konfigurationssache, aber ja. Ist eigentlich, achso da habe ich mal eine Gegenfrage: Wenn ich jetzt so ein, Spring ist eigentlich ein gutes Beispiel, also früher wurden ja, hat man so Java-Code gehabt und dann hat man außerhalb von diesem Java-Code hatte man ne XML-Datei und hat damit konfiguriert, die Software. Also hat gesagt, dass sind meine Beans, meine Spring-Beans, das ist mein Application-Kontext und so weiter. Und dann ist das ja mal irgendwann, XML war nicht mehr so hip und dann ist das sozusagen in den Code gewandert mit Annotationen. Und so Klassen, also man theoretisch diese Klassen auch einfach, also den Inhalt der dieser Klassen kann man auch irgendwie überall im Code verstreuen, aber meistens wenn man es vernünftig macht, macht man so eine Configuration-Class oder vielleicht sogar eine Hierarchie davon, was das, was man früher in XML konfiguriert hat, das war ja dann ganz ersichtlich auf jeden Fall Konfiguration, weil es ein extra File war vielleicht oder so, was dann jetzt extra Klassen sind. Aber das ist ja auch Konfiguration… also, es ist zwar Code, aber es ist Konfiguration. Und ich glaube das wird bei anderen Tools auch so sein, dass viele viele Konfigurationen irgendwie in den Code wandern, weil es ja auch noch diesen, diese… wie sagt man? Diese Strömung gibt „everything as code“ eigentlich. Also wird es wahrscheinlich sogar noch zunehmen. Das heißt es ist dann nicht mehr so einfach rauszufinden, habe ich es jetzt mit Code-Code zu tun oder mit Konfigurations-Code? Und der macht natürlich dann auch Probleme, ne? Weil wie benutze ich die Spring-Konfiguration zum Beispiel ändert sich auch ständig. Und manchmal kommen vielleicht coole Sachen dazu, die ich unbedingt benutzen will oder so. Wo ich vielleicht… genau, das ist auch so ein Problem, das hatten wir ja sogar in dem Beispiel-Projekt an der Bauhaus-Uni, wo wir eigentlich so einen lokalen Entwicklungsprozess gebraucht haben, wir hatten dieses Frontend, was irgendwie auf nem Node-JS-Server bereitgestellt wird und das Spring-Backend. Und hatten dann diese Cores(?)-Probleme, diese Command-Object-Request-Irgendwas, ne? Diese wo dann diese Single-Origin-Policy irgendwie vom Browser sagt „ne, darfst du nicht aufrufen“ und da gibt es jetzt mittlerweile eine „add cross-origin“-Annotation, die einem komplett mal alle Probleme löst. Aber vorher hatte ich da irgendwie drei Seiten Code geschrieben. In zwei verschiedenen Programmiersprachen. Was, also, das ist ja auch so ein… das konfiguriere ich jetzt mit diesem „add cross-origin“. Das ist für mich eine Konfiguration, aber dahinter passiert ja dann Magic.

R3: Ist das immer, also das ist ja jetzt einfach das im Code zu konfigurieren. Ist das dann immer einfach? Also macht es denn Sinn generell alles im Code, also oder mehr Sachen im Code…

I1: Also ich würde sogar sagen, es verleitet halt, wie jetzt in dem Beispiel gesagt, dazu, dass man die Konfiguration über den ganzen Code verstreut. Also wenn ich da nicht ganz harte Richtlinien sozusagen im Team, also Richtlinien ist immer so ein hartes Wort, aber bei diesem Fall würde ich wirklich tatsächlich irgendwie, dass man so ein Code of Conduct oder so dafür einrichtet oder irgendwie sich darauf einigt, weil sonst hat man ein echtes Problem wenn dann der ganze, die ganze Implementierung irgendwie nur noch überall nur noch verstreut Konfigurationen enthält und wie kriegt man das wieder irgendwie zusammen. Also, speziell… es ist auch sehr wichtig, dass man da halt irgendwie Testgetrieben vorgeht, dann merkt man das immer sehr schnell wenn dann die Leute überall ihren… ihre Konfiguration verstreuen, weil meistens im Test möchte man halt die Konfigurationsklasse dafür oder die Konfiguration mit reinziehen um halt den Kontext herzustellen und wenn das dann nicht geht, dann merkt man „aha, du hast gar keine Konfigurationsklasse, du hast einfach irgendwie alles im Code verstreut“, dann… ja. Ich glaube konfigurierbare Software zu bauen ist halt auch so ein best-practice in der Softwareentwicklung… was man einfach tun sollte. Aus vielen Gründen. Und ja, das halt irgendwie herzustellen, das ist dann wieder so eine Frage, wie man das macht. Test-driven Development wäre eine so eine Möglichkeit… die dem Entwickler gleich selber auf die Füße fällt. Wenn der jetzt sagt „naja, meine Software ist nicht konfigurierbar“, aber das krieg ich ja nicht mit. Das fällt erst im Betrieb auf die Füße, weil da nicht in der Produktivdatenbank reingehen kann, dann ist das vielleicht zu spät, aber…

R1: Okay, was ist denn… nach ihrer Erfahrung besonders so ein besonders schwer zu konfigurierendes Framework oder Tool und warum ist denn das schwer konfigurierbar?

I1: Hm, schwer konfigurierbares Tool… mir fallen jetzt sofort Spring Cloud Netflix ein… was wie gesagt diese Konfigurationsparameter von zwei auf fünfzig gefühlt hebt. Das ist unter anderem glaube ich deshalb schwer… also einmal hat man halt genau diese Probleme drunter ja liegen, die das wegkapseln soll, der verteilten… von verteilten Systemen. Das heißt man hat auf einmal, muss ich halt irgendwelche Endpunkte von allen möglichen Dingen eintragen, ich muss ihm halt sagen „da ist deine Service-Registry und da ist dein was-weiß-ich-Endpunkt und hier nimm mal bitte noch das Spring Boot Admin, der da läuft, aber eigentlich sollst du das gar nicht wissen, also fragst du über die Registry ab“ und naja, dann kann ich allen noch Timeouts vergeben wie sie untereinander registrieren und wie sie dann aber eigentlich auch den fachlichen Request und sowas. Und das riesige Problem dabei ist auch, es ist sehr… verglichen mit den Spring Boot Sachen sehr schlecht dokumentiert. Also es gibt exponentiell mehr Konfigurationsmöglichkeiten, die sehr viel schlechter dokumentiert sind. Das ist so ein Ding, das macht es halt extrem schwer. Genauso wenn ich jetzt Richtung Infrasktrutur/DevOps und so denke, da fällt mir sofort Jenkins ein. Jenkins ist nämlich so ein Ding, was sich eher schlecht konfigurieren lässt oder sagen wir mal so, es hat extrem viele Bausteine, die ich beachten muss um dieses Ding in so einer… wie soll ich sagen, Infrastructure as Code-Manier hochzuziehen… weil es einfach… es ist halt irgendwie immer ne Krücke das Ding zu… was zum Beispiel GitLab viel besser macht, also… wobei das bei Jenkins glaube ich eher die Historie ist, das Ding gibt es schon ewig und wird immer wieder Abwärtskompatibel weiterentwickelt.

R2: Was macht GitLab besser?

I1: Naja, da kann ich halt tatsächlich das meiste konfigurieren, also…

R2: Jenkins ist schwer zu konfigurieren, weil man es nicht konfigurieren kann?

I1: Naja… man kann es nicht mit einer einheitlichen Schnittstelle wirklich komplett konfigurieren. Also das wichtige ist eingentlich, dass man irgendwas… wenn das irgendwie sagen wir mal hier ein Konfigurations…API hat, dass man das dann darüber auch vollständig konfigurieren kann und das ist bei Jenkins nicht so. Da gibt es halt ganz viele… wenn ich jetzt irgendwie das eine Thema kann ich da konfigurieren, das nächste muss ich das machen, das nächste muss ich an der anderen Stelle machen und hier muss ich dann eigentlich noch mal manuell dann da klicken, was ich natürlich nicht will, weil ich will es ja komplett hochziehen ohne, dass jemand draufguckt. Und dann, das macht GitLab halt besser, das kann ich tatsächlich… und was mir auch einfällt, das ist jetzt zum Beispiel Kubernetes, wenn man sowas selber betreiben will und hochziehen will, dann ist das auch Hölle komplex und… da ist es tatsächlich auch so, diese vielen Moving Parts, die das halt mitbringt, also es sind eigentlich immer, wenn ich ganz viele Dinger habe, die ich irgendwie zusammen konfigurieren muss, ganz viele einzelne Teile, dann wird es halt komplex… mit der Konfiguration. Also… weil keine Ahnung, das zerfällt ja in… das kann man ja vergleichen mit Docker Swarm, das ist ja auch so ein Container Scheduler, da hab ich halt im Endeffekt einfach nur dieses Dockerding, was ich irgendwie zusammen(?) benutzen muss (R1: (?)) ja, und bei Kubernetes habe ich irgendwie, keine Ahnung, zwanzig Komponenten, die ich erstmal irgendwie integrieren muss. Die aber alle Wechselwirkungen haben und alle richtig zueinander stehen müssen und so.

R2: Also sozusagen wieder als würdest du viele kleine Tools wieder konfigurieren, also ist eigentlich das nur eine Ebene tiefer.

I1: Ja, genau.

R2: Okay… also das heißt die Tools, die schwer zu konfigurieren sind, sind die die im Prinzip wieder zerfallen (I1: Ja) in kleine Tools.

I1: Ja, genau. Weil da muss ich mit jeder Konfigurations-API von jedem Tool rumschlagen und das auch richtig machen und…

R2: Machen das die meisten so, oder?

I1: Na, viele versuchen dann halt das irgendwie zu umgehen und versuchen halt sowas, wo ich dann sozusagen mal ganz platt gesagt ein ausführbares Programm habe, was ich dann irgendwie konfiguriere und das macht dann alles im Hintergrund für mich. Zum Beispiel Kubernetes-Installer oder sowas oder gerade Vectide aus der Cloud irgendwo einfach benutzen, die Schnittstelle und fertig. Und gar nicht groß… naja, konfigurieren schon, die haben dann halt irgendne Weboberfläche, wo du da so die wichtigsten Sachen vergibst. Irgendwie den Clusternamen und die IP-Address-Range und dann sagst du „create“ und das war's. Und alles im Hintergrund läuft irgendwie für dich… transparent.

R2: Okay… So, dann gehen wir mal weiter. Es gibt ja Konfigurationsabhängigkeiten über Framework-/Toolgrenzen hinweg. In wie weit spielen die denn eine Rolle für, erstmal für die persönliche Arbeit?

I1: Genau, über die Tools hinweg ist, also eigentlich würde ich das sagen, wenn ich jetzt die Frage richtig verstehe, ist jetzt praktisch das gleiche Thema, wie… ich hab mehrere Tools in meinem Stack und die muss ich halt integrieren und das ist eigentlich, wie gesagt, pro Tool ist das immer sehr gut dokumentiert… und vielleicht noch mit dem am meisten verwendeten Nachbartool ist auch noch ganz gut dokumentiert und dann hört es auf.

R2: Und wie beeinflusst das deine persönliche Arbeit? Weil du hast ja vorhin gesagt (I1: Genau, also) du hast drei Stunden oder vier Stunden gestern versenkt.

I1: Da geht eigentlich die meiste Zeit rein, weil… das Tool für sich ist eigentlich immer relativ schnell… aufgesetzt oder man kann halt gut nachlesen oder sich einarbeiten, da gibt es auch viele Kurse und so, aber grad diese Integration… von mehreren Tools ist halt wahrscheinlich sogar mit die Hauptarbeit dann. Weil da ist halt dann auch immer ein bisschen Forschung und Entwicklung sozusagen, wie es immer so schön heißt. Wo man nicht so… (?) schwer auch dem Projektmanagement dann zu kommunizieren. Weil man dann sagen muss „ich hab keine Ahnung wie lange das dauert. *Keiner* hat eine Ahnung wie lange das dauert.“ (lacht) „Wir sollten es aber tun und dann…“ (…) Ja, also… das ist schon ein wesentlicher Teil und wesentlicher Arbeitstreiber.

R2: Wie beeinflusst das die Fehler? Fehlerfreiheit?

I1: Auch dementsprechend stark, weil alles was sozusagen… also oft sind das dann Pfade, die nicht so oft gegangen werden. Also komischerweise sogar sehr häufig, also das ist eigentlich eine ganz komische Erfahrung, die ich aber schon oft gemacht habe, gerade wenn man sagt „naja, wir wollen jetzt ein neues Projekt starten, was nehmen wir denn für einen Tech-Stack?“ und dann sagt man „okay, wir nehmen das hier, wir nehmen das hier, wir nehmen das, wir nehmen das, wir nehmen das“ und alles ist, sagen wir mal, de facto Standard gerade. Dann gehe ich mal in meinem naiven, jugendlichen Leichtsinn davon aus naja, dann muss das ja auch gut zusammenarbeiten… Nein (lacht) und es ist nicht dokumentiert oder sehr wenig dokumentiert…

R2: Also das heißt die Dokumentation ist eigentlich das Hauptproblem.

I1: Genau. Also sei es jetzt direkt vom Hersteller oder von dem Tool irgendwie auf der Webseite oder halt auch bei irgendwelchen Sachen wie Stackoverflow oder… ja.

R1: Gibt es auch… Gründe das vielleicht das auch gar nicht zusammenpasst, also?

I1: Genau, das kann auch rauskommen. Also… es kann ja sogar sein, man hat das Tool vielleicht gar nicht richtig verstanden. Was es überhaupt macht. Also man geht davon aus, ich nehme jetzt ein Tool um Messaging zu machen und dann stellt sich raus, das ist vielleicht für was ganz anderes gedacht. Und dann hat man natürlich irgendwie ein Problem, aber… manchmal ist das auch nicht so ersichtlich, also… weil natürlich auch wieder Herstellerinteressen dahinter stehen und… das hatte ich auch am Dienstag bei dem Startup… war genau dieses Thema. Wir haben zwei Probleme, das eine ist Infrastrukturmonitoring und das andere ist fachliches Logging/Logkorrelation über mehrere Anwendungen. Und ganz, wenn man die Themen für sich betrachtet, könnte man sagen, die aktuellen State-of-the-Art-Tools für das eine Problem ist Prometheus, für das Monitoring und für das Logging/Logkorrelationen Elastic Search oder überhaupt der ganze Elastic-Stack. So, wenn man jetzt aber auf die Webseiten guckt, dann sind da auf einmal nicht nur diese Themen die sie, für die sie sozusagen gedacht waren drauf, sondern sind, beim Elastic Stack sagen wir mal, ganz viele Monitoring-Themen. Und dann sitzt man da mit dem Kunden und der sagt „guck mal, die können ja auch Monitoring“ — „Ja, (lacht) *kann* man auch machen, das *wollen* die auch, dass man das so macht, aber vielleicht ist es mit dem anderen Tool besser.“ das heißt es gibt dann auch noch dahinter dann irgendwelche Interessen, die da versuchen vielleicht… wo also Unternehmen dahinter stehen, die wollen dann einfach nen breiteren Markt… haben, durchdringen… wachsen und so weiter und dann… wird das also auch verwässert. Also es gibt da keinen klaren Blick drauf, man muss denen eigentlich immer wieder… schaffen, das ist eigentlich… Hauptarbeit sozusagen dabei. In der Beratung. Aber das hat jetzt mit Konfiguration vielleicht weniger zu tun.

R2: Wie beeinflusst das dann das Deployment, diese ganzen Abhängigkeiten?

I1: Ja auch stark, ne? Weil ich muss ja das… also das Deployment setzt ja dann voraus… also modernes Deployment läuft kontinuierlich ab, das heißt also möglichst fünf mal am Tag geht man in Produktion mit Änderungen. Oder vielleicht, man geht sogar dahin, dass jeder Commit eines Entwicklers direkt nach Produktion geht. Und dann muss ja dieser ganze Prozess vollständig automatisiert sein, also da kann keiner mehr irgendwo ne Hand anlegen, höchstens maximal noch sagen „okay, das soll jetzt 20&nbsp;% der Leute schon erreichen“, so mit so einem Blue-Green- oder Canary-Deployment und wir testen das jetzt mal in so einer kleinen Gruppe. Das kann man vielleicht noch konfigurieren, aber der Rest ist komplett automatisiert. Und dann muss natürlich auch das… diese ganzen Bestandteile müssen alle vollständig automatisiert deploybar sein und eben auch automatisiert konfigurierbar sein. Also das hängt dann dran. Das heißt es ist extrem wichtig für das Deployment, dass die Konfiguration dann passt.

R2: Wahrscheinlich dann auch genauso für das Testing, oder?

I1: Für das Testing… ist es vorallem dann… Unit-Tests machen meistens sichtbar, ob man irgendeine Sache überhaupt unittesten kann. Wenn das nicht sozusagen konfigurierbar ist, dann… wird es halt schwierig irgendwie.

R1: Also vielleicht eine andere Frage dann

(PAUSE)

R1: Ist eigentlich noch die Konfiguration, spielt die beim Team-Meeting, also wenn wir jetzt mal so ein Scrum-Meeting haben oder sowas, eine besondere Rolle oder wird das einfach weggedrückt irgendwie?

I1: Ich würde sagen eher… weniger, also eher so in dem Ding, dass man sagt es gibt da ein Problem und wir müssen da mal draufgucken, aber dann die weitere Diskussion, die Lösung ist dann eher so mit diesem, genau diesem technischen Entwickler oder den technischen Entwicklern… davon gibt es meistens auch nicht so viele. Also meine Erfahrung ist, Fachentwickler sind meistens mehr da. Also wenn ich in so einem Team habe, dann habe ich vielleicht sechs Fachentwickler und zwei, drei die sich eher so um diese… technischen Themen und… hab ich vielleicht vorhin auch vergessen bei den Rollen, also eher dieses Lead-Developer, die vielleicht auch sagen so entwickel ich überhaupt, also man kann ja auch so und so entwickeln. (…) rein auch im Code, wie testgetrieben oder wie gehe ich vor oder so. Und das beschränkt sich dann eher auf einen kleinen Kreis, die das dann lösen und dann zum nächsten Scrum-Meeting wieder mitbringen und sagen „hey… läuft jetzt“ oder so.

R1: Vielleicht eine Anschlussfrage: (…) gesagt, dass es (…) immer ne sehr starke Rolle für die Fehlerfreiheit, für das Deployment, eigentlich für alles, es ist eine extrem starke Rolle und trotzdem ist das anscheinend ne untergeordnete Rolle im Scrum-Meeting jetzt zum Beispiel. Ist das ein Widerspruch? Würde man sich da wünschen, dass das mehr thematisiert wird, oder?

I1: Das berührt eine ganz alte… ne ganz alte Wunde bei mir, weil ich schon immer eher an diesem technischen, ich sage jetzt mal, früher hieß das klassisch Framework-Entwickler oder so, also das gab es auch immer, meistens hat sich das schon in der Organisationsstruktur gezeigt, es gab zum Beispiel zehn Fachentwicklerteams, die aufgeteilt waren nach den Funktionen des Unternehmens zum Beispiel, also für Marketing gab es ne Abteilung, für was weiß ich, ne? Für Backendprocessing gab es ne Abteilung und so weiter. Und ein Team war dann sozusagen für die komplette Software-Entwicklung, also wie entwickelt man, mit welchen Tools und so weiter, zuständig. Und das ist immer unterrepräsentiert, weil im Unternehmen habe ich ja Business-Ziele. Und die Business-Ziele schlagen sich auch heute im, natürlich im Scrum wieder und ganz oft ist es aber so, dass dann das Backlog halt gefüllt ist mit fachlichen Zielen, fachlichen Userstorys, was auch immer und du hast aber auch technische Userstorys. Und das ist für mich ein total ungelöstes Thema, wenn man sozusagen keinen Scrum-Master hat, der immer wieder drauf achtet das zumindest sowas wie 30&nbsp;% der Items oder der Tickets dann immer auch technische oder Architektur-Themen, dann hat man immer das riesen Problem, dass die anlaufen. Also die sammeln sich als Bodensatz im Backlog und werden immer mehr und die technischen Schulden halten aber, das versteht oft der fachliche Teil eher nicht, dass diese, sich ansammelnden technischen Schulden dafür sorgen, dass die fachlichen Tickets viel langsamer, immer weiter langsamer und viel weniger umgesetzt werden können, weil ich mich immer wieder mit irgendwelchen Workarounds beschäftige, die halt da sind, die da sein müssen, weil die technischen Sachen nicht so laufen wie sie sollen. Das heißt, aus meiner Sicht ist das halt ein riesen Thema in dem… dass das halt eigentlich keine große Rolle spielt, obwohl das extrem viel ausmacht, wie ich meine Softwarearchitektur gestalte auf das, was ich dann hinterher im Business machen kann. Das ist halt dann immer so eine extrem große Herausforderung. Gerade auch, ich sag mal, bei vielen Kunden, wo ich jetzt unterwegs war, das waren halt Finanzdienstleister. Wo man erst so langsam, langsam versteht, dass das Kerngeschäft eines Finanzdienstleisters vielleicht doch IT ist. Und nicht nur irgendso eine Shared-Service-Abteilung, die ich am besten noch outsource. ...

Aber es ist ein ungelöstes Problem… also aus meiner Sicht.

R1: Sehr gut, ja… vielleicht, wir hatten ja vorhin noch nach einem schwer einzelnes Tool zu sprechen, vielleicht nochmal, vielleicht ganz kurz eine Antwort oder so, gibt es es spezielle Kombinationen aus Frameworks/Tools und so weiter, die schwer zu konfigurieren sind? Und warum?

I1: (lacht) Kombinationen, da fällt mir gar nichts ein (sarkastisch) (lacht).

R2: Also die Frage muss dann weiter nach oben. (Zustimmung der anderen)

R1: Ja, also… oder gibt es vielleicht

I1: Irgendwie hatten wir, die doch auch schon mal so in abgewandelter Form.

R2: Ja okay, dann hören wir noch mal rein denke ich.

R1: Okay… also die Frage ist eher so

I1: … vielleicht war die Frage, die vorhin war, glaube ich, Frage welche Tools sind an sich schwer zu (R1: Ja, genau) konfigurieren und jetzt welche Tools sind in Kombination schwer zu konfigurieren (R1: Ja). Die gleichen. Wenn ich die konfiguriere, wird es noch schlimmer.

(Lachen)

R1: Das ist doch eine kurze und knappe Antwort.

I1: Also wird es noch viel schlimmer. Und dann habe ich noch mehr ein Problem wenn das im Scrum-Meeting kein Thema ist.

R1: Ah okay. Wie werden eigentlich Konfigurationen verwaltet?

I1: Oh (lachen) und dann hatte das Interview noch eine zusätzliche Stunde.

(Lachen)

I1: Tatsächlich vor zehn Jahren, als ich angefangen habe, war Konfiguration immer noch so ein nice-to-have, was man gerne… was die Leute, die so best-practice-mäßig unterwegs waren, einfach gemacht haben, weil sie wussten, dass man wir das brauchen und viele hatten halt noch nicht konfigurierbare Software gebaut oder die Konfiguration irgendwie ignoriert oder irgendwo hingeschrieben oder was weiß ich. In irgendwelchen Files, die halt keiner kannte. Möglichst außerhalb des Versionskontrollsystems… was war die Frage?

R1: Wie wird es verwaltet?

I1: Ja genau, also die Verwaltung ist ein… riesen Thema, was auch immer meistens unbeantwortet blieb in der ganzen Zeit, die ich jetzt in der Software-Entwicklung bin, weil die Konfiguration hat ja, ist ja direkt abhängig vom Code. Also wenn ich jetzt irgendwas am Code ändere… also die Konfiguration wird ja meistens irgendwie eingelesen in den Code und wird da irgendwie verwendet. Und wenn ich… also… wenn ich den Code jetzt ändere und ich habe irgendeine Konfiguration, die nicht mehr zum Code passt, dann habe ich ja ein Problem. Das kann ja potentiell ständig passieren wenn sich Code-Änderungen ergeben können. Das heißt, ich muss eigentlich die Konfiguration immer in Abhängigkeit vom Code verwalten und da Code im Versionskontrollsystem liegt, sollte Konfiguration auch immer im Versionskontrollsystem verwaltet werden. Am besten irgendwie direkt verknüpft. Oder zumindest nah beieinander oder so. Das war früher oft nicht so und das war ein riesen Thema. Da wollten auch viele Hersteller das irgendwie lösen mit sogenannten Configuration-Management-Databases und die sollten riesig eingeführt werden in Big-Bang-Sachen in Unternehmen. Das hat *nie* geklappt, ich hab es *nie* gesehen, dass das geklappt hat. Weil die Hersteller das meistens versuchen generisch irgendwie zu lösen, das Thema. Und das hat aber nie funktioniert, weil die ganzen einzelnen Software-Entwicklungsprozesse einfach komplett verschieden waren und diese ganzen Anforderung abzudecken war mega schwierig. Jetzt mit dieser ganzen Thematik Microservices, DevOps, Continuous Delivery und so weiter, ist es oft so, dass diese Infrastructure as Code Tools oder DevOps-Tools das einfach mit dabei haben, wie man Konfigurationen verwaltet. Weil die genau wissen, die haben ja das Problem… ich muss nicht nur was deployen, sondern ich muss es auch entsprechend konfigurieren. Das heißt heute wenn wir zum Beispiel in einem Projekt so Tools, wie Ansible einsetzen, dann empfehle ich halt auch immer (…) die Konfigurationen da direkt dort auch abbilden. Ist immer am einfachsten. Und führt halt dazu, dass das Zeug im Versionskontrollsystem steht und führt dann zu so lustigen Anrufen, wenn die Infrastruktur-Admins dann bei dir anrufen und sagen „Ähm du, wir hatten doch mal diesen Server da. Ich weiß, ihr macht doch das mit dem Ansible. Kannst du noch mal da in den (?) gucken, da steht doch wie die IP und (lacht) die, der Datenbankname war von diesem und jenem… Produkt oder so, dass er dann.“ Also, das wird dann automatisch irgendwie genutzt. Also Versionskontrollsystem ist am besten.

R1: Okay, wenn ich jetzt sagen wir mal überlege, jetzt hat man, jedes Tools hat seine eigene Datei und so weiter, alles liegt in Versionskontrolle und so weiter Systemen(?)… also bedeutet das es wird… man hat eine globale Übersicht, oder man hat keine globale Übersicht, oder man braucht sie nicht, oder?

I1: Das ist eine gute Frage. Ich würde fast sagen, man braucht diese globale… wozu braucht man denn die globale Sicht? Das wäre jetzt die erste Frage. Also ich glaube man braucht die Sicht immer dafür um ein Stück Software, was irgendwie laufen muss damit das läuft. Dafür brauche ich die komplette Sicht auf diese Software. Wenn die jetzt mal in einem Beispiel aus fünf Microservices besteht, die jeweils einzeln konfiguriert sind, dann brauche eine Sicht auf alle fünf Microservices. Dann muss halt die gesamte Konfiguration für diesen Anwendungsteil da sein. Damit der Anwendungsteil läuft, braucht er aber nicht vielleicht eine ganz andere Software, die auf irgendwie monolithisch basiert irgendwo anders auf irgendeinem anderen Server liegt, da brauche ich vielleicht die Sicht nicht drauf. Das ist auch… das ist auch glaube ich unrealistisch, dass man das jemals kriegt. Also in großen Unternehmen ist es glaube ich einfach komplett utopisch, dass man, ja… dass man jemals so eine Gesamtsicht kriegt. Also das war ja aus meiner Sicht einer der Gründe, warum auch diese Einführung von diesen Configuration-Management-DBs gescheitert ist, weil das ist so weit weg von den Businesszielen. Also wenn schon diese technischen Themen, da eigentlich dafür da sind um das Projekt nach vorne zu bringen nicht Thema des Scrum-Meetings sind… dann muss man sich mal überlegen, dass sind noch, noch viele Schritte zurück zu sagen, ich tue jetzt irgendwelche Configuration Items über das gesamte Unternehmen zusammenführen. Das hat einfach überhaupt nichts mit dem Business zu tun und dann wird es nicht gemacht.

R1: Ah, okay… Ok, bloß noch mal zum klarstellen, also Konfigurationen werden auch nicht im Team kommuniziert oder so?

I1: Was heißt kommuniziert? Wo man jetzt was einstellen müsste damit irgendwas geht, oder?

R1: Ja, oder

R2: Wird das irgendwie besprochen in Meetings oder weiß ein anderes Teammitglied welche Konfigurationen und Abhängigkeiten

I1: Also oft gibt es halt irgendwie Wikis, wo schon steht wenn du jetzt in dem Teilbereich bist, du beschäftigst dich mit Docker, da gibt es schon meistens schon so eine FAQ und dann wird meistens verwiesen dann direkt auf die entsprechenden Stellen im Versionskontrollsystem. Das ist eigentlich so üblich. Und wenn ich das halt alles im Versionskontrollsystem habe, kann ich sogar nachschauen wenn es nicht dokumentiert ist. Das ist ja immer dann schon Doku. Weil es ist da drin. Wenn es außerhalb ist, keine Chance. Wenn das nur irgendeiner weiß, der dann vielleicht gerade im Urlaub oder krank ist, dann.

R1: Ok, also wird das nicht gesagt, wenn ich jetzt nicht gesagt wenn ich jetzt mal meinen Port ändere… im nächsten Meeting… Achtung, ich habe jetzt meinen Port geändert, sondern man muss dann selber…

I1: Naja gut, also solche Schnittstellenthemen, die werden schon kommuniziert oft. Klar. Also das ist, also wenn das irgendwie Auswirkungen auf die Zusammenarbeit im Team hat, oder zwischen Komponenten, die jetzt mehrere Leute betreffen, dann wird das schon kommuniziert. Dann ist das auch sehr schnell auf einmal Thema im Scrum-Meeting. Das ist vielleicht ganz witzig. Also solange es nur als technische Schuld irgendwo im Backlog liegt, ist das so „pff, naja diese technischen blabla, ja das müssen wir jetzt nicht machen. Ich will jetzt meinen Button haben!“, ja? So. Damit der Fachbereich glücklich ist. Aber sobald irgendwas nicht geht, kriegt man auf einmal, ich meine das kann jetzt dazu führen, dass man dann eine gewisse Taktik entwickelt, aber dann kriegt man auf einmal sogar ganze Sprints wo man nur technische Themen macht. Ne, weil dann ist es ja auf einmal wichtig. Wenn wirklich alles steht, dann darf man machen. (lacht) Ein Schelm, wer sich jetzt denkt, dass… nein, also, aber das ist schon so ein Thema und klar, an diesen Schnittstellen ist es immer (???)

R2: Funktioniert denn diese Art der Kommunikation, oder ist das eher problematisch?

I1: Die ist in sofern problematisch, weil sie meistens… irgendein Tech-Entwickler/Lead-Entwickler oder was auch immer, technischer… Kollege ändert was und sagt „ich hab im Kubernetes-Cluster im CNI-Plugin… von CubeDNS auf was weiß ich umgestellt“ und die anderen Fachentwickler sitzen da… mit offenem Mund und… großen Augen. Ne, so. Und oft ist gar nicht so unbedingt erkennbar für die, also es kommt wieder auf den Menschen drauf an, der das macht, aber oft sind dann diese sehr, sehr technisch orientierten Leute vielleicht auch eher… ein bisschen introvertiert, autistisch verlanlagt und die erzählen dann technische Details, die die anderen nicht verstehen. Aber die Auswirkungen, die die anderen spüren werden, von denen sagen sie nichts. (lacht) Und das ist natürlich ein Problem.

R1: Okay, vielleicht auf für dich noch wichtig für deine, das steht jetzt nicht so direkt drauf. Bei der Kommunikation, ist das dann generell eher so im Person-to-Person, also steht man sich gegenüber oder gibt es auch, oder E-Mail, oder…

I1: Achso, ich habe jetzt viel von agilen Prozessen geredet, ne? Es gibt natürlich auch noch ganz, ganz, also da ist es ja, das sind alles kleine Probleme sag ich mal, weil man da miteinander redet. Aber in großen Organisationsstrukturen, wo diese Konfigurationen, die für ein Softwaresystem notwendig ist, über mehrere Abteilungen oder Teams verteilt ist… Oh Gott, oh Gott. Da kann es sogar sein (R2: Hast du das schon erlebt?) Ja, schon oft. Da kann es sogar sein, dass irgendwas geändert wird in der Konfiguration und keiner kriegt es mit von den anderen. Also das wird dann vielleicht irgendwo in ein Teamwiki geschrieben… weil das die Richtlinie war, dass man jetzt dokumentieren muss und auf das Teamwiki hat leider keiner außerhalb des Teams Zugriff. Und von jetzt auf gleich geht gar nichts mehr und das Problem ist aber, das andere Team, das Softwareentwicklungs-Team ist vielleicht dafür, für den Service verantwortlich, dass das Ding irgendwie da ist oder funktioniert und es geht aber nichts mehr und dann… sozusagen… dann gibt es ein riesen Problem, weil… das passiert ganz oft mit diesen, sagen wir mal, Infrastruktur-Themen, die man jetzt nicht so… die man einfach nicht auf dem Schirm hat, also sowas wie eine Netzwerk-Konfiguration oder so. Ja, irgendwelche Firewall-Regeln oder, oder irgendwelche Webapplication-Firewalls, die jetzt auf einmal Sachen filtern, die sie vorher nicht gefiltert haben, das sind so ganz, ganz beliebte Sachen. Die… wo auch die Leute, die das konfigurieren überhaupt keinen Einblick haben, was das für Auswirkungen hat. Das, was man machen müssen, weil irgendwelche Vorgaben sind aus sicherheitstechnischen oder von irgendwelchen Audits oder so. Ja, und dann… und meistens treten diese Dinge natürlich geballt auf. Also mehrere von diesen Dingen auf einmal. Weil irgendwie ein Audit jetzt und gleichzeitig ist irgendwie ein Projektabschluss und bei dem ist noch, was weiß ich, das Framework gerade kaputt, weil irgendeine Abhängigkeit kaputt ist und das kommt alles natürlich zusammen. Also Murphys Gesetz ist es auch immer.

R1: Okay, jetzt haben wir eigentlich diese Rubrik abgeschlossen. Ich glaube die nächste können wir auch ein bisschen auch kürzer halten, weil wir schon vieles… eigentlich schon mit behandelt haben. Genau, also das wäre jetzt Konfigurationsfehler. Da haben wir jetzt schon viel drüber geredet. Aber vielleicht noch mal grob, was sind denn Konfigurationsfehler… ne Einschätzung, also wie würde man das sagen „das ist jetzt hier ein Konfigurationsfehler.“?

I1: Ja, also wenn vielleicht die, die Konfiguration nicht mehr zur Softwareversion passt, oder wenn die Konfiguration vielleicht augenscheinlich funktioniert… das richtige Ergebnis herbeiführt, aber vielleicht irgendwelche Wechselwirkungen/Nebenwirkungen hat, die man nicht sieht. Also ich konfiguriere das so, dass meine Software geht und damit, dafür mache ich aber jetzt irgendein Security-Problem auf oder so. … Oder Performance-Problem. Das ist glaube ich das, was am häufigsten passiert wenn ich mal so drüber nachdenke. Also irgendeine, irgendein… irgendeine Konfiguration führt dazu, dass meine Software zwar erstmal läuft und da guckt auch keiner mehr drauf, weil das läuft auch so durch in allen Tests, alle Tests sind super. Wenn ich dann vielleicht keine automatisierten Performancetests habe, dann geht das nach Produktion und auf einmal… macht halt diese Software zum Beispiel statt vorher irgendwie gepoolte Datenbank-Connections nutzt das jetzt halt immer persistente Verbindungen, die einzeln neu aufgemacht werden, jedesmal wenn hier auf die Datenbank zugegriffen wird und leider wird in der Software halt 200 mal auf die Datenbank zugegriffen pro Webservice-Call und jetzt kommen halt 10.000 Webservice-Calls. Parallel pro Sekunde und jedesmal gehen, also dann fährt man mal einmal komplett die Produktion an die Wand und hat halt *ein* Konfigurationsding, was an sich, lokal sah das gut aus, auch auf dem Continuous Integration Server noch und dann ist halt aber… die Produktion.

R2: Das ist also mit der schwerwiegendste Fehler? Oder der schlimmste?

I1: Ja, das sind, das sind so solche Sachen sind, sind oft. Aber was war der schwerwiegendste Fehler? … Ja, eigentlich meistens sind es diese Performance-Sachen oder, dass halt Teile der Service-Funktion irgendwie abgeklemmt werden ausversehen. Das halt, vielleicht geht irgendso ein, mein Use-Case, den ich immer so auch noch mal durchklicke, der funktioniert irgendwie… ganz gut. Sieht normal aus. Aber dann in einem, irgendeinem Zusammenhang funktioniert jetzt halt gar nichts mehr oder so. Das ist halt… aber das ist auch sehr schwer im Griff zu behalten in so einem riesen Software-Zoo.

R2: Und wie oft treten so Fehler auf?

I1: Gute Frage, also das kommt glaube ich immer auf die Teamgröße/Unternehmensgröße und so an. In dem letzten Unternehmen wo ich war, das war nicht so groß… da hatte man tatsächlich die meisten Probleme haben zwei, die zwei hauptsächlichen Entwicklungsteams… verursacht sage ich jetzt mal, also… die haben halt gearbeitet und weil wer sägt, da fallen Späne oder so. Aber… wenn ich das jetzt in einer großen Organisation sehe… also große Organisationen werden eigentlich automatisch irgendwie gefühlt langsamer, weil sie halt irgendwie den ganzen Zoo auch irgendwie einfangen müssen. Das ist irgendwie, glaube ich, bisschen fast naturgemäß. Außer man setzt halt wirklich massiv diese ganzen Vorgehensweisen ein, wie Test-Driven Development und continuous, continuous, continuous und irgendwie Blue-Green und sonstwas.

R1: Kannst du das irgendwie so quantifizieren wie oft das jetzt auftreten.

I1: Ah, das ist schwierig. Also, wie oft tritt das auf? Also wie gesagt, immer Murphy, das heißt immer geballt. Also ich würde mal sagen, also so… also da in diesem Unternehmen, das waren halt insgesamt 150 Leute und die zwei Entwicklungsteams hatten vielleicht jeweils so zehn, zwölf Leute, 15 Leute. Das heißt bei 30 Leuten und da trat das vielleicht so alle… zwei bis vier Wochen mal auf, dass mal so richtig schön was eingecheckt wurde, was… dann auch durchgelaufen ist. Und ich würde aber sagen (R1: Bis zur Produktion?) Genau, was bis zur Produktion durchgelaufen ist und man kann ja noch sagen, was sind so Konfigurationsfehler oder irgendwelche Fehler, die dann, das ist schon häufiger vorgekommen, also da kann es schon sein, dass das mal so einmal am Tag oder so. Tut schon jemand was einchecken, was irgendwie Stuss ist und dann… bleibt auch mal irgendwas stehen oder so.

R1: Das wird aber vorher abgefangen, meistens?

I1: Ja, man versucht das dann abzufangen, aber… manchmal ist aber auch das Abfangen teurer als dass es auftritt. Wenn du jetzt zu viele Akzeptanztests und Oberflächentests baust, dann musst du die halt auch warten. Die sind halt extrem wartungsintensiv und dann muss man halt immer abwägen was baue ich jetzt wirklich. Genau, da fällt mir was ein, was wir gar nicht hatten vorhin. Ne Konfiguration, gerade bei diesen Maven, also wenn ich jetzt Microservices baue, dann habe ich ja Services, die für sich erstmal stehen. Aber im Grunde kann man ja sagen, dass sind ja wie gesagt diese Probleme, die ich mit Monolithen hatte, multipliziert, wenn ich jetzt in einen so einen Service reingucke, dann ist der ja oft trotzdem noch modular an sich aufgebaut. Das heißt der hat jetzt verschiedene Abhängigkeiten und die Abhängigkeit kann jetzt sein… dass man das, was ich halt vorhin gedacht habe, dass man irgendeine Maven-Bibliothek oder irgendeine Library reinzieht, die man halt nutzt, die ist jetzt am Markt, Open-Source verfügbar ist. Aber es ist ganz oft auch so — da kommt der Framework-Entwickler — dass ich innerhalb des Teams oder innerhalb des Unternehmens halt Frameworks baue, die ich anderen Entwicklern zur Verfügung stelle. Und die haben ja einen eigenen Entwicklungszyklus und werden aber mit den gleichen Mechanismen eingebunden. Das heißt die haben irgendwo ein Git-Repository, daraus wird irgendwie per Build-Prozess, jetzt Maven oder Gradle oder sowas, ein Artefakt erzeugt, das wird in irgendein Repository gestellt, wie so ein Nexus oder sowas, oder Artefactory. Und aus diesem Artifactory ziehen sich das wieder andere in ihre Software und nutzen das. Und da kann natürlich, da passiert auch unglaublich viel. Also zum Beispiel ganz, ganz und das ist glaube ich noch schlimmer als diese Performance-Dinge und so, ja ich glaube das ist das schlimmste Problem… ist, wenn ich sage ich habe ein fachliches Datenmodell, also sagen wir mal ich bin jetzt in einer Versicherung und habe halt so diese ganzen Dinge, die ich da habe, hier Kunde und (?) und Antrag und Auftrag und sowas. Und die haben irgendwelche fachlichen Attribute. Und das Ding wird halt entwickelt von zwei, drei Leuten, die das halt so ein bisschen im Auge behalten und dann… ändern die das. So, und das nutzt jetzt jede von diesen Microservices — das ist natürlich ein Anti-Pattern, das würde ja *nie* einer so bauen, weil alle haben das DBD-Buch bis zum Erbrechen gelesen und verstanden (sarkastisch) … nicht. Also nutzen das jetzt alle Microservices und da kann ich ja in jedem Microservice sagen ich nutze jetzt dieses fachliche Framework in der Version. Und da können ja auch, also da können und passieren so viele Fehler. Weil jetzt ändert der, der eine Microservice hat die Anforderung jetzt im Backlog irgendeine Userstory jetzt abzubilden. Dafür braucht er drei neue Felder in diesem fachlichen Datenmodell. Das wird jetzt geändert, der zieht das bei sich rein, dann stellt man fest ach ne, ich muss auch noch drei bestehende Felder *ändern*. Dann zieht der das bei sich rein, dann wird das fachliche Feature entwickelt, der Sprint ist rum, alles ist schön. Dann kommt der nächste Microservice, der ist im nächsten Sprint dran, gibt es es wieder Änderungen an dem Datenmodell, der nimmt das, merkt schon „oh, da hat sich ja was geändert. oh, hm, da muss mal drei Tests anpassen. Ah, das geht nicht mehr so. Ah, ja, das wird schon irgendwie gehen. Ich füge noch meine drei Felder noch hinzu und ändere noch fünf andere und erstelle eine neue Version.“. Und dann irgendwann, zwei Monate später, keiner hat mehr an das Ding gedacht und keiner an diese Änderungen, passiert irgendwas. Dass vielleicht irgendeine SQL-Injection, steht in diesem fachlichen Datenmodell drin, also alle müssen auf einmal dieses neue, die neuste Version nutzen. Von dem Datenmodell. Und ziehen das gedankenlos halt rein, suche einfach „latest“ beim, im Artifactory „ah ja, da sind fünf Versionen, da gibt es ja schon fünf neue Versionen, nehmen wir einfach mal die neuste“ und dann geht *gar nichts* mehr. Alle ziehen das rein und überall brechen alle Tests zusammen, keiner weiß was passiert hier eigentlich. Da fehlen dann irgendwelche, das kompiliert nicht mehr, die Tests laufen nicht mehr, wenn man es irgendwie compilefähig gemacht und keiner weiß mehr… was los ist. Und das kann man dann so… alle… zwei, drei Wochen wieder machen. Weil es immer wieder passiert. Das ist eigentlich… und das ist ja auch konfiguriert, also ich konfiguriere das in meiner pom.xml, neue Version vom fachlichen Datenmodell und ist nur eine Konfiguration und das zerschießt alle.

R2: Das ist jetzt aber kein Konfigurationsfehler, oder?

I1: Naja… ja, was ist das? Also ich (R1: Fachlicher Fehler, oder?) konfiguriere es, aber es ist ein… ja… macht vielleicht sichtbar, also das ist halt wahrscheinlich das Problem, man muss erstmal Konfigurationsfehler definieren. (R1: Genau) Ist das ein Fehler, der passiert, weil ich was konfiguriere, oder es ist es ein Fehler, weil die Softwarearchitektur Banane ist, oder?

R2: Naja, darum fragen wir dich, was du dazu meinst, was ein Fehler ist. Also speziell jetzt ein Konfigurationsfehler.

I1: Ja, also ich würde es wahrscheinlich schon eher in die Richtung drehen, dass man jetzt sagt ich konfiguriere irgendein Framework falsch oder so.

R1: Ja, dann kommen wir nämlich gleich, das passt nämlich eigentlich gut zur nächsten Frage… vielleicht können wir dem noch mal auf den Grund gehen. In wie weit unterscheiden sich denn Konfigurationsfehler oder -probleme von normalen Software-Bugs? Oder Fehler, die vielleicht durch fachliche Tests gefunden werden können. Und wie weit unterscheiden die sich vielleicht in der Anzahl und in der… zeitlichen Aufwand für Lokalisieren dieses Fehlers und deren Behebung?

I1: Also ich glaube fachliche Fehler sind in der Anzahl schon mehr. Die sind aber auch schneller zu beheben meistens, weil ich dann vielleicht sage okay ich habe jetzt hier irgendwie, ich sage jetzt mal die if-Abfrage ist falsch, die passiert irgendwie auf dem falschen Wert oder irgendwas frage ich halt falsch hier ab oder, oder… dann ist das meistens schneller zu beheben. Ah, wir haben aber eins vergessen. Wir haben eins vergessen in der ganzen Diskussion, das fällt mir aber gerade bei der Frage auf. Das wäre vielleicht noch ganz interessant für den Fragebogen, ob man das vielleicht irgendwo vorher abfängt sozusagen. Und zwar, gibt es ja nicht nur die, aber ich komme jetzt drauf wegen fachlichem Datenmodell, es gibt ja nicht nur die technische Konfiguration von Docker, Kubernetes, Spring Cloud, was weiß ich, sondern es gibt ja auch fachliche Konfigurationen. Also es gibt, das haben wir sogar relativ häufig schon eingesetzt, dass man sagt man hat wieder Finanzdienstleister, die bauen irgendeine Software und die haben zum Beispiel irgendwelche Zinssätze, die die innerhalb von Berechnungen verwenden oder Altersgrenzen, ganz beliebt, oder Mindestalter, Maximalalter… maximale Einkommensgrenzen, sonstwas, sowas. Was sich potentiell einmal im Jahr ändert wenn irgendso eine Basel II, Basel III, Basel IV und hier gibt es noch diese gesetzliche Änderung und so. Und das wird dann sehr gerne konfiguriert. Also wir haben damals zum Beispiel dem einen Kunden haben wir einen… Tooling eingesetzt, was auf so einem OpenG-Standard basiert, also so ähnlich wie BPMN gibt es so einen DMN, Domain Model and Notation, was eigentlich in der Implementierung her nichts anderes als eine Entscheidungstabelle ist. Was aber meistens ausreicht, weil ich irgendwie sage ich habe hier einen Eingangsparameter, wenn der kommt, dann nimm die Konfiguration. Ist aber sehr mächtig, weil wenn ich das alles als if-then-else runterprogrammiere, dann steht das halt so im Code. Wenn ich aber sage, ich dynamisiere das über so eine fachliche Konfiguration, dann habe ich halt mehrere Vorteile. Ich kann zum Beispiel auch diese Entscheidungstabelle mit dem Fachbereich entwickeln. Also der versteht die sogar, der kann die selber sogar im Extremfall sogar pflegen, ohne die Software zu ändern. Ist auch eine Konfiguration. Ja, aber ich weiß nicht, ob das so vom Thema her passt. (R2: Das gehört schon mit dazu, zur Konfiguration) Also das gehört eigentlich schon eigentlich schon dazu, ist halt jetzt eher fachlich motiviert dann.

R1: Und das würden aber die fachlichen Entwickler schon… betreffen, oder?

I1: Jaja, also…

R1: Also wir haben ja einen (?)-Entwickler, die fachlichen Entwickler. Das heißt, die beschäftigen sich im Grunde ja auch dann mit Konfigurationen.

I1: Genau, die beschäftigen sich auch mit Konfiguration. Also was die technischen Entwickler, in dem Fall also ich, was ich da gemacht habe, war dieses Framework bereitzustellen, zu sagen wie benutzt man das und, aber dann die eigentlichen fachlichen Inhalte da einzufügen, also welche Grenzen gibt es und das dann so zu benutzen, das war dann Fachentwickleraufgabe. Und da kann natürlich dadurch, dass ich es konfigurieren kann auch wieder Fehler passieren. Das heißt ich muss natürlich diese Konfiguration, also im Endeffekt kommt bei diesem DMN-Standard so ein XML raus, das muss auch wieder in die Versionskontrolle. Weil es muss zur Software passen. Und wenn sich die Software ändert und das Ding, und ich brauch halt wieder massiv Testing.

R1: Gibt es da Interaktion eigentlich, zwischen fachlicher Konfiguration und technischer Konfiguration?

I1: Ne, eigentlich nicht. Eher weniger.

R1: Also vielleicht, dass ich, wenn ich das Datenmodell ändere, brauche ich eine andere Datenbank oder sowas.

I1: Ja, okay. Datenbank ist sowieso noch mal ein eigenes spannendes Thema. Und Daten, Datenmodelle, Datenbanken. Weil, was viele Unternehmen dann nicht haben, also sie konfigurieren alles mögliche, aber ihre Datenbank ist irgendwie, da gibt es irgendwie so ein paar SQL-Skripte, die die anlegen und die Schemata anlegen und sowas, aber die liegen halt nirgendwo versioniert und vorallem wenn sich die Software ändert, wird das nicht geändert und so. Das muss dann immer einer manuell einspielen. Und da versucht man aber auch immer die Sachen Richtung… dass man irgendwie sowas, wie Flyway oder Liquibase einsetzt, dass dann diese Schema-Updates auch noch mit in der Versionskontrolle liegen. Aber… dann hätte es ja irgendwie sowas, also das hat so eine technische Komponente, wie benutze ich Liquibase, wie richte ich das ein? Aber eigentlich ist es ja fachlich motiviert. Ich brauche irgendwie neue Felder. Damit ich es in der Datenbank speichern kann oder so. Aber so richtig… so richtige Wechselwirkungen, hm… also ne Wechselwirkung wäre für mich wenn das eine sich ändert, muss ich das andere ändern. Also wenn ich das jetzt richtig verstehe mit Wechselwirkungen. Das kann ich jetzt nicht so richtig erkennen, weil das eine löst erstmal ein technisches Problem, also wie nutze ich zum Beispiel überhaupt Liquibase oder wie nutze ich überhaupt Docker mit Vagrant und Spring Boot oder so und das andere ist, ich ändere jetzt irgendwie einen Zinsparameter und oder brauche ein neues Feld oder so.

R1: Was mir da als Beispiel einfällt ist halt, ich habe jetzt in der Fachlichkeit einen Parameter , der dafür sorgt, dass ich jetzt mehr Last habe auf dem Server und dadurch muss ich mehr

I1: Ah, okay. Ja, stimmt. (R1: Instanzen hochfahren) Das ist natürlich… also es kann natürlich… ja… hm… also das passiert ja auch relativ häufig, dass man zum Beispiel man bringt ein Produkt an den Markt, die Architektur ist für eine gewisse Last ausgelegt und nach zwei, drei Jahren wird das auf einmal massiv gekauft oder so und überhaupt erst mal richtig benutzt und dann reicht vielleicht das ganze nicht mehr aus, aber das ist dann nicht nur ein Konfigurationsproblem.

R1: Also ich hätte jetzt vielleicht, wenn wir bei Netflix bleiben, die haben fachliche Konfiguration wäre vielleicht die Auflösung der Videos, die (?) verschicken. Und je nachdem was ich da konfiguriere muss ich ja wahrscheinlich meine Infrastruktur konfigurieren. But

I1: Ja… ja, oder vielleicht auch bei einer Bank, ne? Ich mache jetzt irgendwie den Zinssatz mache ich so attraktiv, dass auf einmal alle irgendwie den Bausparvertrag wollen oder sowas. Gut, dann habe ich erst dadurch eigentlich ein Infrastrukturproblem. (R1: Ja, aber das ist eher selten). Aber es ist… ja, das ist dann fast eher kein direkter Zusammenhang, sondern sowas wie eine… weiß ich nicht, also… das passiert dann halt. Das sieht wie eine Abhängigkeit aus, aber… ja. Ich würde auch nicht sagen, dass das dann ein Konfigurationsproblem ist. Das ist meistens dann eher „habe ich die Software so skalierbar gebaut, dass es geht oder nicht?“. Und dann habe ich viele Probleme wenn ich es nicht gemacht habe. *Eins* davon ist Konfigurationsprobleme, aber ich hab garantiert noch mehr.

R1: Vielleicht bloß noch ein letzter Punkt dazu, zu den na hier… zu den Unterschieden. Die Behebung… waren ja irgendwie… stärker. Was, wie lange dauert es denn so einen Konfigurationsfehler jetzt zu beheben und was sind da praktisch typische Vorgehensweisen um das jetzt zu beheben?

I1: Naja, meistens hat man ja, also das größte Problem hatte ich ja schon so beschrieben als dieses ich muss jetzt mehrere Sachen integrieren oder ich bin dann weiter fortgeschritten im Lebenszyklus der Software und irgendwas wird geupdatet oder ändert sich oder ich ein neues Framework einnehmen und dann ist eigentlich oft die Vorgehensweise, dass man so sucht, so sehr zu isolieren erstmal das Problem, dass man sagt erstmal das Problem überhaupt zu verstehen. Dass man möglichst viele von den Tools außen rum erstmal wegnimmt, die irgendwie auch noch mit reinspielen und erstmal die zwei Dinger findet, die jetzt nicht zusammen wollen. Und dass man das erstmal löst, für sich. Komplett am besten auch losgelöst von der Kundeninfrastruktur und was die alles noch drumrum bauen und haben und speziell, sondern wirklich am besten auf reiner, dass man erstmal die, ich sage immer so schön, die Frage erstmal formulieren kann. Die man bei Google eingibt. Das ist eigentlich schon immer die… mindestens 50&nbsp;% der Tätigkeit (?) behaupten ja eigentlich mehr. Eigentlich 70&nbsp;% der Tätigkeit ist überhaupt erstmal die Frage formulieren zu können. Weil wenn ich die formulieren kann, dann bin ich auch sehr schnell bei einer Lösung. Meistens gibt es dann sogar schon ne Stackoverflow-Frage dafür, aber… bis ich erstmal weiß, was ich überhaupt sozusagen suchen muss, das ist…

R2: Okay, also typischerweise um so einen Konfigurationsfehler zu finden ist halt solange rumzuspielen bis man ne Google-Frage stellen kann, sozusagen?

I1: Solange isolieren, also immer weiter… also sozusagen die Zwiebel so lange schälen bis nur noch der absolute Kern da liegt und dann wieder jede Schale wieder dranzusetzen. Dass dann am Ende wieder die ganze Anwendung draus wird. Also das ist eigentlich immer wieder die… so ein typisches Problem ist zum Beispiel… ich kann eine Webseite nicht mehr aufrufen. So, und jetzt weiß ich halt, ich habe darunter zehn Server und ich benutze Docker und Kubernetes oder sowas. Dann würde ich halt wirklich anfangen und sagen ok, jetzt gehen wir mal in den einen Dockercontainer, der ganz hinten steht, ganz hinten der Backend-Webserver und geh da rein und versuchen jetzt direkt im Dockercontainer erstmal die Webseite aufzurufen. Wenn das funktioniert, dann gehen wir raus aus dem Dockercontainer und versuchen das aufzurufen, wenn das funktioniert, gehe ich raus aus der Maschine und versuche es… von draußen auf die Maschine, wenn das funktioniert, versuche ich das in dem Spring Cloud Cluster aufzurufen, wenn das funktioniert, nehme ich den Loadbalancer, der davor… nehme ich noch irgendwie ne Kubernetes API und dann, ne? Also ich arbeite mich weiter nach außen und irgendwann habe ich wieder alles dabei, mit Login und sonst was und irgendwas davon wird es ja sein.

R2: Okay, wie gehst du sonst noch vor um Fehler zu finden? Also du hast jetzt gesagt googeln wahrscheinlich, auf Stackoverflow nachgucken

I1: Naja gut, vieles ist natürlich Erfahrung dann auch irgendwie. Dann gibt es natürlich noch sowas wie Remote-Debugging, wenn es jetzt irgendwie Software ist, die man selber im Griff hat. Wo man den Code hat. Dann… kann man das natürlich versuchen. Aber halt auch viel erstmal lokal nachstellen. Also das ist ja auch so ein Isolierungsschritt, dass es nicht auf irgendeinem Server ist, der wieder irgendwie außerhalb meiner… des eigenen Rahmens ist, ja die Isolation ist es eigentlich auf das Wesentliche. Ich glaub… was gibt es noch für Strategien?

R2: Gespräche mit Kollegen?

I1: Ja klar, natürlich. Also das ist sogar natürlich immer Schritt 1, also… das kommt dann natürlich auch immer im Scrum-Meeting, also so ich, so würde ich es hier jetzt aufschlagen. Entweder Scrum-Meeting oder man hat halt irgendso ein … das wird ja Second Level Support, also so angerufen. Und jemand hat die Telefondings auf sich und der legt einen Hörer auf und sagt „hey… Jonas,“, jetzt in dem Fall, „ich hab hier den und den Fehler, kannst du mal gucken?“. Und dann fängt es eigentlich an, so ein bisschen die… also meistens kommt es schon irgendwie kommunikativ an oder per Email oder… oder irgendein externer… man hat da irgendwie so eine Business-to-Business Webservice-Geschichte und dann kriegt man halt eine Email, hier wir haben den und den Fehler. Könnt ihr mal gucken?

R2: Aber das ist ja jetzt wie du einen Fehler bekommst, sozusagen. (I1: Ja) Und wenn du den lösen möchtest, redest du da auch mit den Kollegen, oder (I1: Achso) ist es wirklich eher, dass du für dich guckst?

I1: Ne, meistens ist natürlich reden am schnellsten. Das kommt aber auch immer auf die… es kommt auf einen selber drauf an und kommt auf die Kollegen drauf an. Also, ich hab eigentlich oft die Erfahrung gemacht, dass es am allerschnellsten ist, wenn man das kommunikativ löst, weil viele Fehler sind doch irgendwo schon bekannt. Oder sind schon mal aufgetreten. Es kann aber durchaus sein, dass entweder die Kollegen nicht so kommunikativ sind… oder, dass… ja, vielleicht, dass es auch nicht irgendwie dokumentiert ist, oder dass es irgendwie wieder vergessen wurde, oder was weiß ich. Oder war, vielleicht ist es auch noch gar nicht, es ist noch gar nicht bekannt. Es ist noch gar nicht aufgetreten. Das gibt es auch. Und manchmal gibt es auch Fehler, die sind noch gar nicht mal irgendwo aufgetreten. Also die hatte tatsächlich noch keiner. Weil diese spezielle Frameworkkombination hat einfach sonst keiner. Dann hat man aber eigentlich vorher was in der Beratung falsch gemacht, aber es kann trotzdem auftreten. Ja, weil man hat ja immer irgendwelche Annahmen. Man will zwar das beste, aber dann hat man halt irgendwas ausgesucht, was… dann doch nicht so weit verbreitet war, wie man… dachte.

R1: Okay, letzte Frage zu den Fehlern: Wie beugt man die denn am besten vor? Konfigurationsfehler.

I1: Ja, tatsächlich ist eine Strategie nicht unbedingt immer nur Bleeding-Edge-Bibliotheken zu verwenden, sondern halt zu sagen, gut… ich nehme jetzt nicht den neuen heißesten Scheiß Blinki-Blinki, sondern… das war ja genau das, was ich vorhin auch meinte mit diesem Spring Cloud Sleuth. Also eigentlich habe ich das, dieses Update, hab ich jetzt ein halbes, dreiviertel Jahr habe ich das ausgesessen. Das gibt es jetzt schon lange, Spring Boot 2\. Aber ich wusste halt, naja, wenn Spring Boot 2 erstmal geupdatet ist, dann kommt die ganze Kaskade danach ja noch. Dann müssen ja erstmal noch die anderen, die das alle benutzen, müssen auch noch updaten und dann muss noch, ne? Also so. Und *trotzdem* waren immer noch Fehler da. Also das ist immer so ein Abwägen dann. Vielleicht jetzt nicht so ganz… frische Ware zu benutzen. Aber halt auch nicht total abgehangene. Man will ja schon irgendwie noch… das ist immer so Abwägen, also.

R1: Und was noch?

I1: Am besten ist so wenig wie möglich Moving Parts im System zu haben. Also jeder, der kommt und sagt „Ich brauche unbedingt Kubernetes“, sagst du erstmal „Warum? Was willst du damit machen? Brauchst du diese ganzen Dinger, diese ganzen Einzeldinger oder reicht dir vielleicht einfache ein simpler, simples Dockerfile oder Dockercompose oder so… aus.“. Also immer reduzieren, Komplexität reduzieren. Weil (R2: Also eine Anforderungsanalyse sozusagen noch mal machen?) ja wenn wenn man schon sagt, dass sozusagen das Problem ist immer wenn mehr integriert werden muss, dann ist die Lösung natürlich weniger zu integrieren. Also wenn ich… wenn viele Knoten Probleme machen, nehme ich halt wenige. Wenn es geht. Aber oftmals werden halt für irgendwelche… Anwendungen, werden da Sachen aufgerufen, wo man halt sagt, das ist jetzt mit Elefanten auf Spatzen… geschossen oder so… (lacht).

R1: Also weitere? Testen oder irgendwas?

I1: Genau. Oder was halt auch immer ganz wichtig ist, ist halt so ein Proof of Concept, also dass man halt sofort nach der Auswahl, oder eigentlich schon während der Auswahl am besten… eigentlich die ganze Zeit immer alles ausprobiert. Experimentation sozusagen, also immer wieder das Zeug zusammensteckt, die Annahmen validiert… nicht glaubt einfach, was im Blogpost steht, auch wenn es 500 dazu gibt. Naja, wenn es vielleicht zehn dazu gibt. Das irgendwann auszuprobieren. Weil es kann sich ja auch schon wieder in nem halben Jahr die ganze Welt geändert haben und dann sind diese Sachen, die da stehen, die waren mal richtig, aber sind jetzt nicht mehr so. Also keine reine PowerPoint-Schlacht.

R1: Eigentlich jetzt letztes Thema: Verbesserungsbedarf.

R2: Bei Konfigurationen.

R1: Bei Konfigurationen.

R2: Nicht beim Fragebogen.

R1: Genau. Ja, welche Verbesserungen würden Sie sich denn hinsichtlich der Konfiguration von Softwaresystemen wünschen? Oder von Frameworks und Tools.

I1: Vorsicht bei API-Änderungen.

R2: Du hattest ja vorhin auch Dokumentation irgendwann angesprochen und gesagt, dass es sowas (?)

I1: Ja, Dokumentation muss eigentlich immer sein und immer aktuell sein. Wo die natürlich alles versuchen sollten zu nutzen, was es irgendwie gibt. Wenn ich Webservices nutze dann nutze ich irgendwie mindestens sowas wie REST, Spring REST Docs oder sowas, wo sozusagen die Dokumentation als kaputt im CI-System gekennzeichnet wird, wenn ich Code ändere, der nicht zur Dokumentation passt und solche Sachen. Also möglichst auch die Dokumentation automatisieren. Soweit es halt geht.

R1: Was kann man sich noch an Verbesserungen wünschen? (?)

R2: Du hast so eine Datenbank angesprochen am Anfang… das Hersteller versucht haben eine generische Lösung zu finden. Würde das funktionieren? Wenn man es richtig macht, also kann man das richtig machen?

I1: Also ich glaube wenn man so weit wie möglich vorne immer anfängt. Also die Probleme entstehen ja meistens wenn der Entwickler irgendwas eingibt, was dann nicht mehr hinten raus irgendwie zusammenpasst. Dann wäre es natürlich am besten wenn ganz vorne schon angefangen wird, also angesetzt wird. Am besten halt in der IDE. Wenn er seinen Code eingibt oder seine Konfiguration und halt direkt ein Popup aufgeht „Ja, das kannst du so konfigurieren. Es sieht auch gut aus, kannst du auch einchecken, *aber* du weißt schon, dass in 90&nbsp;% der Fälle dann hinterher ein mega Performanceproblem entsteht wenn du das tust.“. Das wäre natürlich super. Also so eine Art…sage ich jetzt mal. Es gibt ja sowas wie Sonar oder so, gibt es ja heute schon, dass du das auch lokal in deiner IDE anwenden kannst. Und dann sagt er „ja, die Methode, die du jetzt geschrieben hast, die kannst du so schreiben, die kompiliert, aber… ist nicht so eine gute Idee, *weil*“, ne? Könnte man das ja genauso mit Konfiguration haben. Und das nächste wäre natürlich… um das zu vermeiden wäre natürlich irgendwie, dass immer massiv alles, jeden (?)-Commit halt sofort… irgendwie gegen eine… ja, alles laufen zu lassen, was ich habe. Am besten die ganze Anwendung hochziehen, einmal durchtesten, das (?) wieder runterschmeißen.

R1: Wird das nicht schon gemacht, ist das?

I1: Ja, das wird oft gemacht. Klar. Das ist natürlich auch ein… wir müssen ja auch irgendwie, sagen wir mal, momentan schon irgendwie… dem Kunden Lösungsstrategien anbieten und das ist halt das, was grad das beste ist, dass man halt möglichst alles immer wieder testet und kontinuierlich integriert. Genau, also so dieses, ich glaube dieses Adit-IDE-Plugin oder so. Das wäre natürlich super. Und dann natürlich vielleicht sowas wie… also ich spinne jetzt mal, was natürlich auch super wäre: Das Problem ist ja immer wenn mehrere Tools miteinander integriert werden. Das sind halt sowieso Konfigurations-, äh so viele Kombinationsmöglichkeiten, ja, am Ende, dass es immer irgendwie einen blinden Fleck geben wird. Da wäre es natürlich cool wenn es sozusagen irgendwas gäbe, was einfach immer alle, ich sage mal so eine Tabelle macht, ja? Frontends, mögliche Backends, mögliche Datenbanken, mögliche Webservice-Schnittstellen, mögliche weiß ich nicht was, da kann man sich ja eine unendliche Tabelle ausdenken und einfach alles immer wieder durchpermutiert. Und alles mal zusammensteckt und für alles so ein Blueprint baut. Das man da eigentlich möglichst sagt, wenn ich jetzt sage ich will das Frontend, mit dem, mit dem, mit dem und dem und sagt, klick, generier mir mal die, die Konfiguration oder so. Die richtige. Das wäre natürlich auch nicht schlecht. Also so eine Art Startup-Skeleton-Prototyping-Dinger oder so.

R1: Was würde denn dann speziell helfen wenn, um Fehler zu identifizieren, vielleicht eine Verbesserung. Also du hast ja gesagt… Schalen, also Zwiebelschalenprinzip, kann man das vielleicht in deiner Einschätzung automatisieren oder so? Oder?

I1: Ja, vielleicht kann man das auch automatisieren. Also entweder, man könnte schon mal automatisieren zu sagen… das jetzt mal als Hilfestellung, demjenigen, der am Bildschirm sitzt… irgendwie mitzugeben. Zu sagen, das ist jetzt irgendwie Datenbank-Fehler, probier doch mal das. Oder so. Bis hin zu, man führt das dann schon durch, also isoliert das irgendwie schon automatisch. Und versucht dann da schon irgendwelche Schlüsse zu machen. Oder sogar bis dahin versucht es dann schon zu lösen. Das Problem.

R1: Ok, dann haben wir jetzt eigentlich alles. Ok, ich denke dann haben wir es.

